/**
 * KRAUSS PDF Document Generator for Retool
 *
 * A streamlined PDF generator for creating employment agreements from API data.
 * Based on the app.js structure but optimized for Retool integration.
 *
 * Dependencies:
 * - PDFMake: https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/pdfmake.min.js
 * - VFS Fonts: https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/vfs_fonts.js
 */

class KRAUSSPDFGenerator {
  constructor(config = {}) {
    this.defaultConfig = {
      pageSize: "A4",

      defaultFont: "Roboto",

      pageMargins: [40, 18, 40, 18],

      companyColors: {
        primary: "#009def",

        secondary: "#666666",

        text: "#333333",

        background: "#f0f0f0",
      },
    };

    this.config = { ...this.defaultConfig, ...config };
  }

  /**
   * Generate PDF document from processed worker data
   * @param {Object} workerData - Processed worker data for document generation
   * @param {Object} options - Generation options (download, open, filename, etc.)
   * @returns {Promise} PDFMake document
   */

  async generateDocument(workerData, options = {}) {
    try {
      // Validate data

      if (!workerData || !workerData.employee) {
        throw new Error("Invalid worker data provided");
      }

      console.log("Creating document definition...");

      // Create document definition using app.js structure

      const docDefinition = this.createDocumentDefinition(workerData);

      console.log("Document definition created successfully");

      console.log("Creating PDF with pdfMake...");

      // Create PDF

      const pdfDoc = pdfMake.createPdf(docDefinition);

      console.log("PDF document object created");

      // Handle output options

      if (options.download) {
        const filename = options.filename || this.generateFilename(workerData);

        console.log("Downloading PDF:", filename);

        pdfDoc.download(filename);
      }

      if (options.open) {
        console.log("Opening PDF in browser");

        pdfDoc.open();
      }

      if (options.getBlob) {
        console.log("Getting PDF as blob");

        return new Promise((resolve, reject) => {
          try {
            pdfDoc.getBlob((blob) => {
              console.log("Blob created successfully");

              resolve(blob);
            });
          } catch (error) {
            console.error("Error getting blob:", error);

            reject(error);
          }
        });
      }

      if (options.getBase64) {
        console.log("Getting PDF as base64");

        return new Promise((resolve, reject) => {
          try {
            pdfDoc.getBase64((base64) => {
              console.log("Base64 created successfully");

              resolve(base64);
            });
          } catch (error) {
            console.error("Error getting base64:", error);

            reject(error);
          }
        });
      }

      console.log("PDF generation completed successfully");

      return pdfDoc;
    } catch (error) {
      console.error("PDF Generation Error:", error);

      console.error("Error stack:", error.stack);

      throw error;
    }
  }

  /**
   * Create document definition using app.js structure
   * Based on createDocumentDefinition from app.js with Retool-specific data
   */

  createDocumentDefinition(workerData) {
    const {
      employee,

      agreement,

      projects,

      specialActivities,

      projectPremiumsByHours,

      totals,

      specialTotals,

      premiums,
    } = workerData;

    return {
      info: {
        title: "KRAUSS Zielvereinbarung",

        author: "KRAUSS GmbH",

        subject: "Zielvereinbarung",

        creator: "KRAUSS BI",
      },

      pageSize: this.config.pageSize,

      pageOrientation: "portrait",

      pageMargins: this.config.pageMargins,

      content: [
        // Header section

        this.createHeaderSection(employee),

        // Employee information table

        this.createEmployeeInfoTable(employee),

        // Agreement section

        this.createAgreementSection(agreement),

        // Agreement text

        this.createAgreementText(agreement, specialActivities),

        // Signatures section

        this.createSignaturesSection(),

        // Projects table

        this.createProjectsTable(
          projects,

          specialActivities,

          projectPremiumsByHours,

          totals,

          specialTotals,

          premiums,

          employee,
        ),
      ],

      defaultStyle: {
        fontSize: 9,

        font: this.config.defaultFont,
      },
    };
  }

  /**
   * Create header section (from app.js structure)
   */

  createHeaderSection(employee) {
    return {
      columns: [
        {
          width: "*",

          stack: [
            {
              text: employee.name,

              fontSize: 16,

              bold: true,

              color: this.config.companyColors.primary,

              margin: [0, 5, 0, 5],
            },

            {
              text: "Zielvereinbarung & Prämienabrechnung",

              fontSize: 11,

              color: this.config.companyColors.secondary,

              margin: [0, 0, 0, 10],
            },
          ],
        },

        {
          width: "auto",

          columns: [
            {
              width: "auto",

              stack: [
                {
                  svg: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" zoomAndPan="magnify" preserveAspectRatio="xMidYMid meet" version="1.0" viewBox="1.69 119.48 1226.26 414.25"><defs><clipPath id="2f4cb618e8"><path d="M 186 488 L 227 488 L 227 533.636719 L 186 533.636719 Z M 186 488 " clip-rule="nonzero"/></clipPath><clipPath id="649dce0913"><path d="M 283 473 L 305 473 L 305 533.636719 L 283 533.636719 Z M 283 473 " clip-rule="nonzero"/></clipPath><clipPath id="c3da070071"><path d="M 310 488 L 351 488 L 351 533.636719 L 310 533.636719 Z M 310 488 " clip-rule="nonzero"/></clipPath><clipPath id="9b89a69596"><path d="M 402 473 L 424 473 L 424 533.636719 L 402 533.636719 Z M 402 473 " clip-rule="nonzero"/></clipPath><clipPath id="764b92b977"><path d="M 483 472 L 519 472 L 519 533.636719 L 483 533.636719 Z M 483 472 " clip-rule="nonzero"/></clipPath><clipPath id="9a790c7a0f"><path d="M 658 488 L 699 488 L 699 533.636719 L 658 533.636719 Z M 658 488 " clip-rule="nonzero"/></clipPath><clipPath id="67984fee79"><path d="M 891 488 L 932 488 L 932 533.636719 L 891 533.636719 Z M 891 488 " clip-rule="nonzero"/></clipPath><clipPath id="0af299fcfd"><path d="M 941 488 L 980 488 L 980 533.636719 L 941 533.636719 Z M 941 488 " clip-rule="nonzero"/></clipPath><clipPath id="7d9fa8d33e"><path d="M 1033 488 L 1071 488 L 1071 533.636719 L 1033 533.636719 Z M 1033 488 " clip-rule="nonzero"/></clipPath><clipPath id="8c1002ef28"><path d="M 1077 473 L 1099 473 L 1099 533.636719 L 1077 533.636719 Z M 1077 473 " clip-rule="nonzero"/></clipPath><clipPath id="c70098f55d"><path d="M 1106 489 L 1143 489 L 1143 533.636719 L 1106 533.636719 Z M 1106 489 " clip-rule="nonzero"/></clipPath><clipPath id="457809df0e"><path d="M 178 119.484375 L 485 119.484375 L 485 440 L 178 440 Z M 178 119.484375 " clip-rule="nonzero"/></clipPath></defs><path fill="#009def" d="M 1.6875 532.742188 L 1.6875 472.550781 L 9.652344 472.550781 L 9.652344 532.742188 Z M 1.6875 532.742188 " fill-opacity="1" fill-rule="nonzero"/><path fill="#009def" d="M 25.109375 532.742188 L 25.109375 472.550781 L 32.503906 472.550781 L 32.503906 494.152344 C 35.957031 490.15625 40.304688 488.167969 45.5625 488.167969 C 48.796875 488.167969 51.59375 488.796875 53.976562 490.070312 C 56.363281 491.34375 58.0625 493.097656 59.085938 495.351562 C 60.113281 497.589844 60.625 500.855469 60.625 505.128906 L 60.625 532.757812 L 53.230469 532.757812 L 53.230469 505.128906 C 53.230469 501.425781 52.425781 498.734375 50.832031 497.066406 C 49.222656 495.382812 46.964844 494.53125 44.039062 494.53125 C 41.84375 494.53125 39.792969 495.105469 37.859375 496.246094 C 35.929688 497.386719 34.550781 498.921875 33.734375 500.871094 C 32.914062 502.816406 32.503906 505.496094 32.503906 508.917969 L 32.503906 532.773438 L 25.109375 532.773438 Z M 25.109375 532.742188 " fill-opacity="1" fill-rule="nonzero"/><path fill="#009def" d="M 74.164062 532.742188 L 74.164062 489.132812 L 80.828125 489.132812 L 80.828125 495.746094 C 82.523438 492.644531 84.089844 490.609375 85.523438 489.628906 C 86.960938 488.648438 88.539062 488.152344 90.269531 488.152344 C 92.757812 488.152344 95.289062 488.941406 97.867188 490.539062 L 95.320312 497.402344 C 93.503906 496.332031 91.703125 495.804688 89.902344 495.804688 C 88.292969 495.804688 86.84375 496.289062 85.554688 497.269531 C 84.265625 498.25 83.34375 499.597656 82.800781 501.308594 C 81.984375 503.929688 81.574219 506.8125 81.574219 509.929688 L 81.574219 532.757812 L 74.179688 532.757812 Z M 74.164062 532.742188 " fill-opacity="1" fill-rule="nonzero"/><path fill="#009def" d="M 130.964844 532.742188 L 130.964844 472.550781 L 138.929688 472.550781 L 138.929688 502.40625 L 168.835938 472.550781 L 179.640625 472.550781 L 154.371094 496.949219 L 180.738281 532.757812 L 170.226562 532.757812 L 148.78125 502.289062 L 138.914062 511.890625 L 138.914062 532.742188 L 130.949219 532.742188 Z M 130.964844 532.742188 " fill-opacity="1" fill-rule="nonzero"/><g clip-path="url(#2f4cb618e8)"><path fill="#009def" d="M 186.066406 510.9375 C 186.066406 502.859375 188.304688 496.890625 192.800781 492.996094 C 196.546875 489.761719 201.128906 488.152344 206.515625 488.152344 C 212.519531 488.152344 217.421875 490.113281 221.226562 494.050781 C 225.035156 497.972656 226.9375 503.402344 226.9375 510.339844 C 226.9375 515.941406 226.089844 520.363281 224.40625 523.582031 C 222.722656 526.800781 220.277344 529.304688 217.054688 531.074219 C 213.835938 532.859375 210.320312 533.738281 206.515625 533.738281 C 200.410156 533.738281 195.476562 531.777344 191.703125 527.871094 C 187.9375 523.960938 186.050781 518.3125 186.050781 510.953125 Z M 193.664062 510.9375 C 193.664062 516.527344 194.878906 520.699219 197.324219 523.480469 C 199.753906 526.261719 202.828125 527.652344 206.53125 527.652344 C 210.203125 527.652344 213.25 526.261719 215.695312 523.464844 C 218.125 520.671875 219.355469 516.425781 219.355469 510.703125 C 219.355469 505.304688 218.125 501.222656 215.679688 498.441406 C 213.234375 495.660156 210.175781 494.269531 206.546875 494.269531 C 202.855469 494.269531 199.78125 495.644531 197.335938 498.410156 C 194.90625 501.175781 193.675781 505.347656 193.675781 510.9375 Z M 193.664062 510.9375 " fill-opacity="1" fill-rule="evenodd"/></g><path fill="#009def" d="M 237.960938 532.742188 L 237.960938 489.132812 L 244.621094 489.132812 L 244.621094 495.339844 C 247.828125 490.550781 252.453125 488.152344 258.5 488.152344 C 261.132812 488.152344 263.550781 488.621094 265.746094 489.570312 C 267.957031 490.507812 269.59375 491.753906 270.691406 493.289062 C 271.789062 494.824219 272.550781 496.640625 272.992188 498.746094 C 273.269531 500.125 273.402344 502.507812 273.402344 505.933594 L 273.402344 532.742188 L 266.007812 532.742188 L 266.007812 506.210938 C 266.007812 503.195312 265.714844 500.941406 265.144531 499.449219 C 264.574219 497.957031 263.550781 496.773438 262.085938 495.878906 C 260.621094 494.988281 258.910156 494.546875 256.933594 494.546875 C 253.785156 494.546875 251.0625 495.542969 248.777344 497.546875 C 246.496094 499.550781 245.351562 503.34375 245.351562 508.917969 L 245.351562 532.730469 L 237.960938 532.730469 Z M 237.960938 532.742188 " fill-opacity="1" fill-rule="nonzero"/><g clip-path="url(#649dce0913)"><path fill="#009def" d="M 303.234375 526.128906 L 304.304688 532.65625 C 302.226562 533.09375 300.367188 533.3125 298.710938 533.3125 C 296.03125 533.3125 293.9375 532.890625 292.476562 532.039062 C 290.996094 531.191406 289.957031 530.078125 289.359375 528.691406 C 288.757812 527.3125 288.449219 524.402344 288.449219 519.96875 L 288.449219 494.882812 L 283.035156 494.882812 L 283.035156 489.132812 L 288.449219 489.132812 L 288.449219 478.332031 L 295.796875 473.898438 L 295.796875 489.132812 L 303.234375 489.132812 L 303.234375 494.882812 L 295.796875 494.882812 L 295.796875 520.378906 C 295.796875 522.484375 295.929688 523.847656 296.195312 524.445312 C 296.457031 525.046875 296.882812 525.527344 297.46875 525.878906 C 298.054688 526.230469 298.902344 526.40625 300 526.40625 C 300.820312 526.40625 301.902344 526.304688 303.25 526.113281 Z M 303.234375 526.128906 " fill-opacity="1" fill-rule="nonzero"/></g><g clip-path="url(#c3da070071)"><path fill="#009def" d="M 341.28125 527.359375 C 338.542969 529.683594 335.910156 531.324219 333.375 532.289062 C 330.84375 533.253906 328.121094 533.722656 325.222656 533.722656 C 320.4375 533.722656 316.746094 532.554688 314.171875 530.210938 C 311.59375 527.871094 310.304688 524.882812 310.304688 521.242188 C 310.304688 519.105469 310.789062 517.15625 311.769531 515.386719 C 312.734375 513.617188 314.007812 512.195312 315.589844 511.144531 C 317.171875 510.074219 318.941406 509.269531 320.90625 508.714844 C 322.355469 508.332031 324.550781 507.96875 327.476562 507.601562 C 333.449219 506.882812 337.839844 506.050781 340.667969 505.054688 C 340.695312 504.046875 340.710938 503.402344 340.710938 503.125 C 340.710938 500.109375 340.007812 497.988281 338.617188 496.757812 C 336.730469 495.089844 333.917969 494.253906 330.199219 494.253906 C 326.714844 494.253906 324.152344 494.871094 322.5 496.085938 C 320.847656 497.300781 319.617188 499.449219 318.824219 502.550781 L 311.59375 501.570312 C 312.253906 498.484375 313.335938 495.980469 314.84375 494.078125 C 316.351562 492.175781 318.53125 490.714844 321.371094 489.6875 C 324.226562 488.664062 327.519531 488.152344 331.269531 488.152344 C 334.988281 488.152344 338.015625 488.589844 340.34375 489.46875 C 342.671875 490.347656 344.386719 491.445312 345.484375 492.777344 C 346.582031 494.109375 347.34375 495.777344 347.78125 497.8125 C 348.03125 499.070312 348.148438 501.339844 348.148438 504.628906 L 348.148438 514.480469 C 348.148438 521.34375 348.308594 525.691406 348.617188 527.519531 C 348.921875 529.332031 349.550781 531.089844 350.488281 532.757812 L 342.773438 532.757812 C 342.011719 531.222656 341.515625 529.4375 341.296875 527.371094 Z M 340.667969 510.851562 C 337.988281 511.949219 333.960938 512.871094 328.589844 513.644531 C 325.542969 514.085938 323.40625 514.582031 322.148438 515.125 C 320.890625 515.664062 319.910156 516.46875 319.234375 517.523438 C 318.546875 518.578125 318.210938 519.75 318.210938 521.035156 C 318.210938 523.011719 318.957031 524.652344 320.449219 525.96875 C 321.945312 527.285156 324.125 527.941406 327.007812 527.941406 C 329.863281 527.941406 332.394531 527.328125 334.605469 526.070312 C 336.832031 524.828125 338.457031 523.128906 339.496094 520.960938 C 340.285156 519.292969 340.679688 516.820312 340.679688 513.574219 L 340.679688 510.863281 Z M 340.667969 510.851562 " fill-opacity="1" fill-rule="evenodd"/></g><path fill="#009def" d="M 361.996094 532.742188 L 361.996094 472.550781 L 369.386719 472.550781 L 369.386719 506.882812 L 386.882812 489.148438 L 396.457031 489.148438 L 379.78125 505.332031 L 398.140625 532.757812 L 389.019531 532.757812 L 374.601562 510.457031 L 369.386719 515.460938 L 369.386719 532.742188 Z M 361.996094 532.742188 " fill-opacity="1" fill-rule="nonzero"/><g clip-path="url(#9b89a69596)"><path fill="#009def" d="M 422.527344 526.128906 L 423.597656 532.65625 C 421.515625 533.09375 419.660156 533.3125 418.003906 533.3125 C 415.324219 533.3125 413.230469 532.890625 411.753906 532.039062 C 410.273438 531.191406 409.234375 530.078125 408.636719 528.691406 C 408.035156 527.3125 407.726562 524.402344 407.726562 519.96875 L 407.726562 494.882812 L 402.3125 494.882812 L 402.3125 489.132812 L 407.726562 489.132812 L 407.726562 478.332031 L 415.078125 473.898438 L 415.078125 489.132812 L 422.511719 489.132812 L 422.511719 494.882812 L 415.078125 494.882812 L 415.078125 520.378906 C 415.078125 522.484375 415.207031 523.847656 415.472656 524.445312 C 415.734375 525.046875 416.160156 525.527344 416.746094 525.878906 C 417.332031 526.230469 418.179688 526.40625 419.277344 526.40625 C 420.097656 526.40625 421.179688 526.304688 422.527344 526.113281 Z M 422.527344 526.128906 " fill-opacity="1" fill-rule="nonzero"/></g><path fill="#009def" d="M 459.59375 532.742188 L 459.59375 494.882812 L 453.0625 494.882812 L 453.0625 489.132812 L 459.59375 489.132812 L 459.59375 484.492188 C 459.59375 481.566406 459.855469 479.386719 460.371094 477.96875 C 461.085938 476.050781 462.332031 474.5 464.132812 473.3125 C 465.917969 472.113281 468.433594 471.527344 471.671875 471.527344 C 473.75 471.527344 476.046875 471.777344 478.566406 472.257812 L 477.453125 478.714844 C 475.914062 478.433594 474.464844 478.304688 473.089844 478.304688 C 470.851562 478.304688 469.253906 478.785156 468.332031 479.738281 C 467.394531 480.6875 466.925781 482.488281 466.925781 485.109375 L 466.925781 489.132812 L 475.433594 489.132812 L 475.433594 494.882812 L 466.925781 494.882812 L 466.925781 532.742188 L 459.578125 532.742188 Z M 459.59375 532.742188 " fill-opacity="1" fill-rule="nonzero"/><g clip-path="url(#764b92b977)"><path fill="#009def" d="M 512.148438 532.742188 L 512.148438 526.332031 C 508.75 531.265625 504.140625 533.722656 498.3125 533.722656 C 495.738281 533.722656 493.335938 533.226562 491.109375 532.246094 C 488.886719 531.265625 487.21875 530.019531 486.132812 528.527344 C 485.050781 527.035156 484.289062 525.207031 483.851562 523.039062 C 483.542969 521.59375 483.394531 519.292969 483.394531 516.132812 L 483.394531 489.117188 L 490.789062 489.117188 L 490.789062 513.308594 C 490.789062 517.171875 490.933594 519.761719 491.242188 521.109375 C 491.710938 523.054688 492.691406 524.578125 494.199219 525.691406 C 495.707031 526.800781 497.566406 527.359375 499.792969 527.359375 C 502.003906 527.359375 504.09375 526.789062 506.042969 525.660156 C 507.988281 524.519531 509.367188 522.980469 510.171875 521.019531 C 510.976562 519.058594 511.386719 516.222656 511.386719 512.503906 L 511.386719 489.148438 L 518.777344 489.148438 L 518.777344 532.757812 L 512.160156 532.757812 Z M 489.558594 480.601562 L 489.558594 472.1875 L 497.289062 472.1875 L 497.289062 480.601562 Z M 504.871094 480.601562 L 504.871094 472.1875 L 512.601562 472.1875 L 512.601562 480.601562 Z M 504.871094 480.601562 " fill-opacity="1" fill-rule="nonzero"/></g><path fill="#009def" d="M 532.613281 532.742188 L 532.613281 489.132812 L 539.273438 489.132812 L 539.273438 495.746094 C 540.972656 492.644531 542.539062 490.609375 543.972656 489.628906 C 545.40625 488.648438 546.988281 488.152344 548.714844 488.152344 C 551.203125 488.152344 553.734375 488.941406 556.3125 490.539062 L 553.765625 497.402344 C 551.949219 496.332031 550.148438 495.804688 548.347656 495.804688 C 546.738281 495.804688 545.273438 496.289062 543.988281 497.269531 C 542.699219 498.25 541.789062 499.597656 541.234375 501.308594 C 540.414062 503.929688 540.003906 506.8125 540.003906 509.929688 L 540.003906 532.757812 L 532.613281 532.757812 Z M 532.613281 532.742188 " fill-opacity="1" fill-rule="nonzero"/><path fill="#009def" d="M 588.796875 532.742188 L 588.796875 489.132812 L 595.414062 489.132812 L 595.414062 495.25 C 596.773438 493.113281 598.605469 491.402344 600.875 490.097656 C 603.140625 488.796875 605.734375 488.152344 608.632812 488.152344 C 611.867188 488.152344 614.515625 488.824219 616.582031 490.15625 C 618.644531 491.503906 620.109375 493.375 620.957031 495.777344 C 624.414062 490.683594 628.890625 488.136719 634.425781 488.136719 C 638.757812 488.136719 642.082031 489.335938 644.410156 491.722656 C 646.738281 494.125 647.894531 497.8125 647.894531 502.785156 L 647.894531 532.730469 L 640.542969 532.730469 L 640.542969 505.261719 C 640.542969 502.304688 640.3125 500.167969 639.828125 498.863281 C 639.34375 497.5625 638.480469 496.523438 637.222656 495.734375 C 635.964844 494.941406 634.484375 494.546875 632.785156 494.546875 C 629.726562 494.546875 627.179688 495.570312 625.144531 497.605469 C 623.125 499.640625 622.101562 502.902344 622.101562 507.398438 L 622.101562 532.730469 L 614.707031 532.730469 L 614.707031 504.398438 C 614.707031 501.117188 614.105469 498.644531 612.90625 497.007812 C 611.707031 495.367188 609.730469 494.546875 606.992188 494.546875 C 604.914062 494.546875 602.980469 495.089844 601.226562 496.1875 C 599.453125 497.285156 598.179688 498.878906 597.390625 500.988281 C 596.597656 503.09375 596.203125 506.136719 596.203125 510.105469 L 596.203125 532.730469 L 588.8125 532.730469 Z M 588.796875 532.742188 " fill-opacity="1" fill-rule="nonzero"/><g clip-path="url(#9a790c7a0f)"><path fill="#009def" d="M 691.09375 518.695312 L 698.734375 519.632812 C 697.535156 524.09375 695.292969 527.5625 692.03125 530.019531 C 688.78125 532.480469 684.609375 533.710938 679.542969 533.710938 C 673.160156 533.710938 668.09375 531.75 664.363281 527.8125 C 660.628906 523.890625 658.753906 518.371094 658.753906 511.289062 C 658.753906 503.957031 660.644531 498.265625 664.421875 494.210938 C 668.199219 490.15625 673.101562 488.136719 679.132812 488.136719 C 684.960938 488.136719 689.730469 490.128906 693.421875 494.09375 C 697.125 498.058594 698.96875 503.648438 698.96875 510.851562 C 698.96875 511.289062 698.953125 511.949219 698.925781 512.824219 L 666.398438 512.824219 C 666.675781 517.613281 668.023438 521.285156 670.46875 523.832031 C 672.910156 526.378906 675.941406 527.652344 679.585938 527.652344 C 682.296875 527.652344 684.609375 526.933594 686.527344 525.515625 C 688.445312 524.09375 689.964844 521.824219 691.078125 518.695312 Z M 691.179688 506.738281 C 690.859375 503.066406 689.921875 500.3125 688.386719 498.484375 C 686.027344 495.628906 682.984375 494.210938 679.222656 494.210938 C 675.824219 494.210938 672.96875 495.351562 670.65625 497.621094 C 668.34375 499.890625 667.070312 502.933594 666.820312 506.738281 Z M 691.179688 506.738281 " fill-opacity="1" fill-rule="evenodd"/></g><path fill="#009def" d="M 710.371094 532.742188 L 710.371094 472.550781 L 717.765625 472.550781 L 717.765625 494.152344 C 721.21875 490.15625 725.566406 488.167969 730.824219 488.167969 C 734.058594 488.167969 736.855469 488.796875 739.242188 490.070312 C 741.625 491.34375 743.324219 493.097656 744.347656 495.351562 C 745.375 497.589844 745.886719 500.855469 745.886719 505.128906 L 745.886719 532.757812 L 738.492188 532.757812 L 738.492188 505.128906 C 738.492188 501.425781 737.6875 498.734375 736.09375 497.066406 C 734.496094 495.382812 732.226562 494.53125 729.300781 494.53125 C 727.105469 494.53125 725.054688 495.105469 723.121094 496.246094 C 721.191406 497.386719 719.816406 498.921875 718.996094 500.871094 C 718.175781 502.816406 717.765625 505.496094 717.765625 508.917969 L 717.765625 532.773438 L 710.371094 532.773438 Z M 710.371094 532.742188 " fill-opacity="1" fill-rule="nonzero"/><path fill="#009def" d="M 759.425781 532.742188 L 759.425781 489.132812 L 766.089844 489.132812 L 766.089844 495.746094 C 767.785156 492.644531 769.351562 490.609375 770.789062 489.628906 C 772.222656 488.648438 773.804688 488.152344 775.53125 488.152344 C 778.019531 488.152344 780.550781 488.941406 783.128906 490.539062 L 780.582031 497.402344 C 778.765625 496.332031 776.964844 495.804688 775.148438 495.804688 C 773.539062 495.804688 772.074219 496.289062 770.800781 497.269531 C 769.511719 498.25 768.589844 499.597656 768.050781 501.308594 C 767.230469 503.929688 766.820312 506.8125 766.820312 509.929688 L 766.820312 532.757812 L 759.425781 532.757812 Z M 759.425781 532.742188 " fill-opacity="1" fill-rule="nonzero"/><path fill="#009def" d="M 827.058594 532.742188 L 811.074219 472.550781 L 819.242188 472.550781 L 828.40625 512.007812 C 829.386719 516.148438 830.234375 520.246094 830.953125 524.328125 C 832.488281 517.890625 833.382812 514.1875 833.660156 513.207031 L 845.125 472.550781 L 854.742188 472.550781 L 863.363281 503.019531 C 865.53125 510.574219 867.082031 517.683594 868.046875 524.328125 C 868.808594 520.523438 869.804688 516.148438 871.050781 511.230469 L 880.492188 472.550781 L 888.5 472.550781 L 871.984375 532.742188 L 864.300781 532.742188 L 851.609375 486.878906 C 850.539062 483.046875 849.910156 480.6875 849.71875 479.8125 C 849.089844 482.578125 848.503906 484.933594 847.949219 486.878906 L 835.183594 532.742188 L 827.042969 532.742188 Z M 827.058594 532.742188 " fill-opacity="1" fill-rule="nonzero"/><g clip-path="url(#67984fee79)"><path fill="#009def" d="M 922.710938 527.359375 C 919.972656 529.683594 917.335938 531.324219 914.804688 532.289062 C 912.273438 533.253906 909.550781 533.722656 906.652344 533.722656 C 901.863281 533.722656 898.175781 532.554688 895.613281 530.210938 C 893.035156 527.871094 891.75 524.882812 891.75 521.242188 C 891.75 519.105469 892.230469 517.15625 893.199219 515.386719 C 894.179688 513.617188 895.453125 512.195312 897.019531 511.144531 C 898.597656 510.074219 900.371094 509.269531 902.332031 508.714844 C 903.78125 508.332031 905.976562 507.96875 908.90625 507.601562 C 914.878906 506.882812 919.269531 506.050781 922.09375 505.054688 C 922.125 504.046875 922.140625 503.402344 922.140625 503.125 C 922.140625 500.109375 921.4375 497.988281 920.046875 496.757812 C 918.15625 495.089844 915.347656 494.253906 911.628906 494.253906 C 908.144531 494.253906 905.582031 494.871094 903.929688 496.085938 C 902.273438 497.300781 901.042969 499.449219 900.253906 502.550781 L 893.023438 501.570312 C 893.679688 498.484375 894.765625 495.980469 896.273438 494.078125 C 897.78125 492.175781 899.960938 490.714844 902.800781 489.6875 C 905.65625 488.664062 908.949219 488.152344 912.695312 488.152344 C 916.414062 488.152344 919.445312 488.589844 921.773438 489.46875 C 924.101562 490.347656 925.8125 491.445312 926.910156 492.777344 C 928.007812 494.109375 928.769531 495.777344 929.210938 497.8125 C 929.457031 499.070312 929.574219 501.339844 929.574219 504.628906 L 929.574219 514.480469 C 929.574219 521.34375 929.738281 525.691406 930.042969 527.519531 C 930.351562 529.332031 930.980469 531.089844 931.917969 532.757812 L 924.1875 532.757812 C 923.425781 531.222656 922.929688 529.4375 922.710938 527.371094 Z M 922.09375 510.851562 C 919.417969 511.949219 915.375 512.871094 910.019531 513.644531 C 906.972656 514.085938 904.835938 514.582031 903.578125 515.125 C 902.316406 515.664062 901.351562 516.46875 900.664062 517.523438 C 899.976562 518.578125 899.640625 519.75 899.640625 521.035156 C 899.640625 523.011719 900.386719 524.652344 901.878906 525.96875 C 903.371094 527.285156 905.554688 527.941406 908.421875 527.941406 C 911.277344 527.941406 913.808594 527.328125 916.019531 526.070312 C 918.246094 524.828125 919.871094 523.128906 920.910156 520.960938 C 921.699219 519.292969 922.09375 516.820312 922.09375 513.574219 Z M 922.09375 510.851562 " fill-opacity="1" fill-rule="evenodd"/></g><g clip-path="url(#0af299fcfd)"><path fill="#009def" d="M 971.851562 516.761719 L 979.113281 517.699219 C 978.324219 522.703125 976.289062 526.625 973.007812 529.464844 C 969.730469 532.304688 965.71875 533.710938 960.945312 533.710938 C 954.972656 533.710938 950.171875 531.761719 946.554688 527.855469 C 942.925781 523.960938 941.109375 518.359375 941.109375 511.085938 C 941.109375 506.371094 941.886719 502.261719 943.453125 498.71875 C 945.019531 495.191406 947.390625 492.542969 950.582031 490.773438 C 953.773438 489 957.242188 488.125 960.992188 488.125 C 965.734375 488.125 969.597656 489.324219 972.613281 491.707031 C 975.628906 494.109375 977.5625 497.503906 978.410156 501.910156 L 971.222656 503.019531 C 970.535156 500.09375 969.320312 497.882812 967.59375 496.40625 C 965.851562 494.929688 963.742188 494.195312 961.285156 494.195312 C 957.566406 494.195312 954.535156 495.527344 952.207031 498.207031 C 949.878906 500.871094 948.722656 505.097656 948.722656 510.878906 C 948.722656 516.734375 949.851562 520.992188 952.089844 523.65625 C 954.328125 526.304688 957.273438 527.636719 960.875 527.636719 C 963.773438 527.636719 966.203125 526.742188 968.148438 524.972656 C 970.097656 523.1875 971.324219 520.464844 971.851562 516.761719 Z M 971.851562 516.761719 " fill-opacity="1" fill-rule="nonzero"/></g><path fill="#009def" d="M 987.792969 532.742188 L 987.792969 472.550781 L 995.1875 472.550781 L 995.1875 494.152344 C 998.640625 490.15625 1002.988281 488.167969 1008.246094 488.167969 C 1011.480469 488.167969 1014.277344 488.796875 1016.664062 490.070312 C 1019.046875 491.34375 1020.746094 493.097656 1021.769531 495.351562 C 1022.796875 497.589844 1023.308594 500.855469 1023.308594 505.128906 L 1023.308594 532.757812 L 1015.914062 532.757812 L 1015.914062 505.128906 C 1015.914062 501.425781 1015.109375 498.734375 1013.515625 497.066406 C 1011.917969 495.382812 1009.648438 494.53125 1006.722656 494.53125 C 1004.527344 494.53125 1002.476562 495.105469 1000.542969 496.246094 C 998.613281 497.386719 997.238281 498.921875 996.417969 500.871094 C 995.597656 502.816406 995.1875 505.496094 995.1875 508.917969 L 995.1875 532.773438 L 987.792969 532.773438 Z M 987.792969 532.742188 " fill-opacity="1" fill-rule="nonzero"/><g clip-path="url(#7d9fa8d33e)"><path fill="#009def" d="M 1033.980469 519.734375 L 1041.285156 518.578125 C 1041.695312 521.503906 1042.835938 523.742188 1044.710938 525.308594 C 1046.585938 526.875 1049.203125 527.652344 1052.570312 527.652344 C 1055.96875 527.652344 1058.484375 526.960938 1060.125 525.574219 C 1061.765625 524.183594 1062.597656 522.574219 1062.597656 520.699219 C 1062.597656 519.03125 1061.867188 517.714844 1060.417969 516.761719 C 1059.40625 516.105469 1056.890625 515.269531 1052.863281 514.261719 C 1047.449219 512.898438 1043.6875 511.714844 1041.59375 510.703125 C 1039.5 509.707031 1037.902344 508.320312 1036.820312 506.5625 C 1035.738281 504.792969 1035.195312 502.84375 1035.195312 500.707031 C 1035.195312 498.761719 1035.632812 496.960938 1036.527344 495.308594 C 1037.421875 493.65625 1038.636719 492.28125 1040.15625 491.183594 C 1041.3125 490.332031 1042.878906 489.617188 1044.855469 489.03125 C 1046.847656 488.445312 1048.96875 488.152344 1051.238281 488.152344 C 1054.664062 488.152344 1057.664062 488.648438 1060.257812 489.628906 C 1062.847656 490.609375 1064.75 491.957031 1065.980469 493.640625 C 1067.210938 495.324219 1068.058594 497.578125 1068.527344 500.402344 L 1061.296875 501.382812 C 1060.972656 499.144531 1060.023438 497.386719 1058.441406 496.128906 C 1056.859375 494.871094 1054.636719 494.242188 1051.765625 494.242188 C 1048.371094 494.242188 1045.953125 494.796875 1044.492188 495.921875 C 1043.042969 497.050781 1042.308594 498.351562 1042.308594 499.859375 C 1042.308594 500.824219 1042.617188 501.6875 1043.21875 502.449219 C 1043.816406 503.242188 1044.769531 503.898438 1046.058594 504.425781 C 1046.789062 504.703125 1048.96875 505.332031 1052.585938 506.3125 C 1057.8125 507.703125 1061.472656 508.859375 1063.535156 509.738281 C 1065.601562 510.628906 1067.226562 511.917969 1068.410156 513.617188 C 1069.582031 515.3125 1070.167969 517.421875 1070.167969 519.9375 C 1070.167969 522.398438 1069.449219 524.722656 1068.015625 526.902344 C 1066.582031 529.085938 1064.503906 530.769531 1061.792969 531.953125 C 1059.085938 533.136719 1056.011719 533.738281 1052.601562 533.738281 C 1046.9375 533.738281 1042.617188 532.566406 1039.644531 530.210938 C 1036.671875 527.855469 1034.785156 524.359375 1033.949219 519.734375 Z M 1033.980469 519.734375 " fill-opacity="1" fill-rule="nonzero"/></g><g clip-path="url(#8c1002ef28)"><path fill="#009def" d="M 1097.5 526.128906 L 1098.566406 532.65625 C 1096.488281 533.09375 1094.628906 533.3125 1092.976562 533.3125 C 1090.296875 533.3125 1088.203125 532.890625 1086.722656 532.039062 C 1085.246094 531.191406 1084.207031 530.078125 1083.605469 528.691406 C 1083.003906 527.3125 1082.699219 524.402344 1082.699219 519.96875 L 1082.699219 494.882812 L 1077.265625 494.882812 L 1077.265625 489.132812 L 1082.699219 489.132812 L 1082.699219 478.332031 L 1090.046875 473.898438 L 1090.046875 489.132812 L 1097.484375 489.132812 L 1097.484375 494.882812 L 1090.046875 494.882812 L 1090.046875 520.378906 C 1090.046875 522.484375 1090.179688 523.847656 1090.441406 524.445312 C 1090.707031 525.046875 1091.128906 525.527344 1091.714844 525.878906 C 1092.300781 526.230469 1093.152344 526.40625 1094.25 526.40625 C 1095.066406 526.40625 1096.152344 526.304688 1097.5 526.113281 Z M 1097.5 526.128906 " fill-opacity="1" fill-rule="nonzero"/></g><g clip-path="url(#c70098f55d)"><path fill="#009def" d="M 1135.660156 532.742188 L 1135.660156 526.332031 C 1132.265625 531.265625 1127.65625 533.722656 1121.828125 533.722656 C 1119.25 533.722656 1116.851562 533.226562 1114.625 532.246094 C 1112.386719 531.265625 1110.730469 530.019531 1109.648438 528.527344 C 1108.566406 527.035156 1107.804688 525.207031 1107.363281 523.039062 C 1107.058594 521.59375 1106.910156 519.292969 1106.910156 516.132812 L 1106.910156 489.117188 L 1114.304688 489.117188 L 1114.304688 513.308594 C 1114.304688 517.171875 1114.449219 519.761719 1114.757812 521.109375 C 1115.226562 523.054688 1116.207031 524.578125 1117.714844 525.691406 C 1119.222656 526.800781 1121.082031 527.359375 1123.308594 527.359375 C 1125.53125 527.359375 1127.609375 526.789062 1129.558594 525.660156 C 1131.503906 524.519531 1132.878906 522.980469 1133.6875 521.019531 C 1134.492188 519.058594 1134.902344 516.222656 1134.902344 512.503906 L 1134.902344 489.148438 L 1142.292969 489.148438 L 1142.292969 532.757812 L 1135.675781 532.757812 Z M 1135.660156 532.742188 " fill-opacity="1" fill-rule="nonzero"/></g><path fill="#009def" d="M 1156.214844 532.742188 L 1156.214844 489.132812 L 1162.832031 489.132812 L 1162.832031 495.25 C 1164.207031 493.113281 1166.023438 491.402344 1168.292969 490.097656 C 1170.5625 488.796875 1173.152344 488.152344 1176.050781 488.152344 C 1179.285156 488.152344 1181.9375 488.824219 1184 490.15625 C 1186.0625 491.503906 1187.527344 493.375 1188.375 495.777344 C 1191.832031 490.683594 1196.3125 488.136719 1201.84375 488.136719 C 1206.164062 488.136719 1209.5 489.335938 1211.828125 491.722656 C 1214.15625 494.125 1215.3125 497.8125 1215.3125 502.785156 L 1215.3125 532.730469 L 1207.964844 532.730469 L 1207.964844 505.261719 C 1207.964844 502.304688 1207.730469 500.167969 1207.246094 498.863281 C 1206.761719 497.5625 1205.898438 496.523438 1204.640625 495.734375 C 1203.382812 494.941406 1201.902344 494.546875 1200.203125 494.546875 C 1197.144531 494.546875 1194.597656 495.570312 1192.5625 497.605469 C 1190.542969 499.640625 1189.519531 502.902344 1189.519531 507.398438 L 1189.519531 532.730469 L 1182.125 532.730469 L 1182.125 504.398438 C 1182.125 501.117188 1181.527344 498.644531 1180.324219 497.007812 C 1179.125 495.367188 1177.148438 494.546875 1174.410156 494.546875 C 1172.332031 494.546875 1170.398438 495.089844 1168.644531 496.1875 C 1166.886719 497.285156 1165.597656 498.878906 1164.808594 500.988281 C 1164.019531 503.09375 1163.621094 506.136719 1163.621094 510.105469 L 1163.621094 532.730469 L 1156.230469 532.730469 Z M 1156.214844 532.742188 " fill-opacity="1" fill-rule="nonzero"/><path fill="#373635" d="M 996.828125 230.894531 C 990.824219 213.464844 979.699219 206.558594 961.355469 206.558594 C 948.429688 206.558594 932.796875 209.867188 932.796875 225.789062 C 932.796875 240.816406 950.832031 244.417969 962.558594 246.523438 C 979.390625 250.140625 1001.9375 254.339844 1016.371094 263.953125 C 1033.203125 275.078125 1043.421875 292.199219 1043.421875 312.628906 C 1043.421875 332.765625 1033.804688 351.996094 1017.878906 364.316406 C 1001.335938 377.238281 978.792969 381.144531 958.046875 381.144531 C 919.269531 381.144531 884.105469 364.316406 874.78125 324.042969 L 919.269531 313.828125 C 925.285156 335.457031 940.921875 342.980469 962.265625 342.980469 C 976.097656 342.980469 994.425781 337.871094 994.425781 320.734375 C 994.425781 303.613281 970.972656 300.304688 958.355469 297.597656 C 921.683594 290.089844 885.601562 279.261719 885.601562 234.1875 C 885.601562 214.945312 893.109375 198.128906 907.851562 185.804688 C 922.886719 173.191406 940.613281 168.976562 959.554688 168.976562 C 995.625 168.976562 1025.09375 181.59375 1037.714844 217.359375 L 996.828125 230.878906 Z M 996.828125 230.894531 " fill-opacity="1" fill-rule="nonzero"/><path fill="#373635" d="M 52.527344 270.246094 L 117.160156 173.175781 L 163.449219 173.175781 L 113.851562 246.800781 L 175.773438 379.332031 L 122.5625 379.332031 L 81.675781 290.078125 L 52.515625 331.84375 L 52.515625 379.332031 L 5.613281 379.332031 L 5.613281 173.175781 L 52.515625 173.175781 L 52.515625 270.246094 Z M 52.527344 270.246094 " fill-opacity="1" fill-rule="nonzero"/><path fill="#373635" d="M 675.5625 379.332031 L 623.550781 379.332031 L 610.929688 336.949219 L 544.191406 336.949219 L 531.265625 379.332031 L 488.886719 379.332031 L 555.007812 173.175781 L 610.929688 173.175781 Z M 577.875 226.664062 L 555.933594 299.089844 L 599.820312 299.089844 Z M 577.875 226.664062 " fill-opacity="1" fill-rule="evenodd"/><path fill="#373635" d="M 859.820312 297.890625 C 859.820312 320.429688 860.128906 343.871094 842.984375 360.703125 C 826.457031 377.238281 802.101562 382.347656 779.554688 382.347656 C 757.917969 382.347656 732.960938 379.039062 716.433594 364.609375 C 695.996094 346.871094 695.089844 323.136719 695.089844 297.890625 L 695.089844 173.175781 L 747.394531 173.175781 L 747.394531 297.890625 C 747.394531 307.507812 747.085938 321.335938 751.902344 329.75 C 758.210938 340.566406 771.136719 343.578125 782.863281 343.578125 C 792.480469 343.578125 806.609375 340.578125 812.625 332.457031 C 819.242188 323.136719 818.335938 308.707031 818.335938 297.890625 L 818.335938 173.175781 L 859.820312 173.175781 Z M 859.820312 297.890625 " fill-opacity="1" fill-rule="nonzero"/><path fill="#373635" d="M 1181.351562 230.894531 C 1175.332031 213.464844 1164.222656 206.558594 1145.878906 206.558594 C 1132.953125 206.558594 1117.320312 209.867188 1117.320312 225.789062 C 1117.320312 240.816406 1135.355469 244.417969 1147.082031 246.523438 C 1163.914062 250.140625 1186.460938 254.339844 1200.894531 263.953125 C 1217.726562 275.078125 1227.945312 292.199219 1227.945312 312.628906 C 1227.945312 332.765625 1218.328125 351.996094 1202.402344 364.316406 C 1185.859375 377.238281 1163.316406 381.144531 1142.570312 381.144531 C 1103.792969 381.144531 1068.628906 364.316406 1059.304688 324.042969 L 1103.792969 313.828125 C 1109.808594 335.457031 1125.445312 342.980469 1146.789062 342.980469 C 1160.621094 342.980469 1178.949219 337.871094 1178.949219 320.734375 C 1178.949219 303.613281 1155.496094 300.304688 1142.878906 297.597656 C 1106.207031 290.089844 1070.125 279.261719 1070.125 234.1875 C 1070.125 214.945312 1077.648438 198.128906 1092.375 185.804688 C 1107.410156 173.191406 1125.136719 168.976562 1144.078125 168.976562 C 1180.148438 168.976562 1209.617188 181.59375 1222.238281 217.359375 L 1181.351562 230.878906 Z M 1181.351562 230.894531 " fill-opacity="1" fill-rule="nonzero"/><path fill="#009def" d="M 300.027344 379.332031 L 251.925781 379.332031 L 251.925781 173.175781 L 338.808594 173.175781 C 357.148438 173.175781 375.785156 173.484375 391.710938 183.699219 C 408.546875 194.820312 417.871094 214.957031 417.871094 235.082031 C 417.871094 258.523438 404.347656 280.15625 382.09375 288.261719 L 420.273438 379.316406 L 366.769531 379.316406 L 335.207031 297.875 L 300.042969 297.875 L 300.042969 379.316406 Z M 300.027344 262.433594 L 326.480469 262.433594 C 336.40625 262.433594 347.226562 263.324219 355.933594 258.230469 C 363.753906 253.417969 367.96875 243.800781 367.96875 234.789062 C 367.96875 226.679688 363.152344 217.957031 356.242188 213.742188 C 348.132812 208.636719 334.300781 209.835938 325.28125 209.835938 L 300.027344 209.835938 Z M 300.027344 262.433594 " fill-opacity="1" fill-rule="evenodd"/><g clip-path="url(#457809df0e)"><path fill="#009def" d="M 178.628906 279.496094 C 178.628906 191.398438 247.328125 119.71875 331.78125 119.71875 C 416.234375 119.71875 484.933594 191.398438 484.933594 279.496094 C 484.933594 367.59375 416.234375 439.273438 331.78125 439.273438 C 247.328125 439.273438 178.628906 367.59375 178.628906 279.496094 Z M 199.503906 279.511719 C 199.503906 356.105469 258.851562 418.417969 331.78125 418.417969 C 404.726562 418.417969 464.058594 356.105469 464.058594 279.511719 C 464.058594 202.914062 404.710938 140.601562 331.78125 140.601562 C 258.835938 140.601562 199.503906 202.914062 199.503906 279.511719 Z M 199.503906 279.511719 " fill-opacity="1" fill-rule="evenodd"/></g></svg>',

                  width: 80,

                  height: 40,

                  margin: [0, 0, 10, 0],
                },
              ],
            },

            {
              width: "auto",

              stack: [
                {
                  text: [
                    { text: "KRAUSS GmbH\n", fontSize: 8, bold: true },

                    { text: "Edith-Stein-Straße 10b\n", fontSize: 8 },

                    { text: "86899 Landsberg am Lech", fontSize: 8 },
                  ],

                  alignment: "left",

                  color: this.config.companyColors.text,

                  margin: [0, 8, 0, 0],
                },
              ],
            },
          ],
        },
      ],
    };
  }

  /**
   * Create employee information table
   */

  createEmployeeInfoTable(employee) {
    // Build base row with employment data

    // Two-row layout:

    // Row 1: Arbeitszeit | Eintrittsdatum | Probezeit Ende  (each as label + value inside a stack)

    // Row 2: SOLL A-Std. | IST A-Std. | (blank / spacer)

    const inlineCell = (label, value) => ({
      text: [
        { text: label + " ", bold: true },

        { text: value, bold: false },
      ],

      fontSize: 9,

      border: [false, false, false, false],

      margin: [0, 0, 6, 0],

      noWrap: true,
    });

    const employmentRows = [
      [
        inlineCell("Arb.-Zeit:", `${employee.workingHours} Std./Woche`),

        inlineCell("Startdatum:", employee.startDate),

        inlineCell("Probezeit bis:", employee.endDate),
      ],

      [
        inlineCell("SOLL A-Std.:", `${employee.sollWorkingHours || 0}`),

        inlineCell("IST A-Std.:", `${employee.istWorkingHours || 0}`),

        { text: "", border: [false, false, false, false] },
      ],
    ];

    // Always show absence table (even if empty) for consistency

    let columns;

    // Debug absence table rendering

    console.log("=== ABSENCE TABLE RENDERING ===");

    console.log("Employee name:", employee.name);

    console.log("absenceSummary:", employee.absenceSummary);

    console.log(
      "absenceSummary length:",

      employee.absenceSummary ? employee.absenceSummary.length : 0,
    );

    console.log("totalFehltage:", employee.totalFehltage);

    console.log("Will show absence table? Always true now");

    console.log("=== END ABSENCE TABLE RENDERING ===");

    // Always show absence table (changed from: if (employee.absenceSummary && employee.absenceSummary.length > 0))

    if (true) {
      // Determine month label similar to agreement date (uses dateRangeSelector if available, else current month)

      let monthLabel;

      try {
        if (
          typeof dateRangeSelector !== "undefined" &&
          dateRangeSelector?.value?.start
        ) {
          monthLabel = dateRangeSelector.value.start

            .locale("de")

            .format("MMMM YYYY");
        } else if (typeof moment !== "undefined") {
          monthLabel = moment().locale("de").format("MMMM YYYY");
        } else {
          const now = new Date();

          const months = [
            "Januar",

            "Februar",

            "März",

            "April",

            "Mai",

            "Juni",

            "Juli",

            "August",

            "September",

            "Oktober",

            "November",

            "Dezember",
          ];

          monthLabel = months[now.getMonth()] + " " + now.getFullYear();
        }
      } catch (e) {
        monthLabel = "";
      }

      // Build absence codes table: group by type (Frei, Urlaub, Krank, etc.)

      // Handle empty absence data

      const hasAbsenceData =
        employee.absenceSummary && employee.absenceSummary.length > 0;

      console.log("Has absence data:", hasAbsenceData);

      let headerRow = [];

      let amountRow = [];

      if (hasAbsenceData) {
        console.log("Processing absence data...");

        // Group absences by type and collect individual codes

        const absencesByType = {};

        const codesByType = {};

        employee.absenceSummary.forEach((absence) => {
          const type = absence.type || absence.code || "Unbekannt";

          const code = absence.code;

          const amount = absence.amount || 0;

          console.log(
            `Processing absence for table: code="${code}", type="${type}", amount=${amount}`,
          );

          // Track by type for summaries

          if (!absencesByType[type]) {
            absencesByType[type] = 0;

            codesByType[type] = [];
          }

          absencesByType[type] += amount;

          codesByType[type].push({ code, amount });
        });

        console.log("Absences grouped by type for table:", absencesByType);

        console.log("Codes by type:", codesByType);

        // Build header and amount rows with individual codes AND type summaries

        // Show each code, then type summary, then total

        Object.keys(absencesByType)

          .sort()

          .forEach((type) => {
            const codes = codesByType[type];

            const totalForType = absencesByType[type];

            console.log(
              `Adding type "${type}" with ${codes.length} codes, total: ${totalForType}`,
            );

            // Add individual code columns

            codes.forEach(({ code, amount }) => {
              console.log(`  Adding code "${code}" with amount ${amount}`);

              headerRow.push({
                text: code || "?",

                fontSize: 7,

                bold: true,

                alignment: "center",

                fillColor: "#f5f5f5",

                margin: [1, 1, 1, 1],
              });

              amountRow.push({
                text: (amount || 0).toString(),

                fontSize: 7,

                alignment: "center",

                margin: [1, 1, 1, 1],
              });
            });

            // Always add type summary column after codes

            console.log(
              `  Adding type summary "Σ ${type}" with amount ${totalForType}`,
            );

            headerRow.push({
              text: `Σ ${type}`,

              fontSize: 7,

              bold: true,

              alignment: "center",

              fillColor: "#e8f4f8",

              margin: [1, 1, 1, 1],
            });

            amountRow.push({
              text: (totalForType || 0).toString(),

              fontSize: 7,

              bold: true,

              alignment: "center",

              fillColor: "#e8f4f8",

              margin: [1, 1, 1, 1],
            });
          });

        /*// Add Total column at end
        headerRow.push({
          text: "SUM ",
          fontSize: 7,
          bold: true,
          alignment: "center",
          fillColor: "#e0e0e0",
          margin: [2, 2, 2, 2],
        });
        amountRow.push({
          text: (employee.totalFehltage || 0).toString(),
          fontSize: 7,
          bold: true,
          alignment: "center",
          margin: [2, 2, 2, 2],
        });*/
      } else {
        // No absence data - show just the total column

        console.log("No absence data - creating empty table with Summe column");

        headerRow = [
          {
            text: "Summe",

            fontSize: 7,

            bold: true,

            alignment: "center",

            fillColor: "#e0e0e0",

            margin: [2, 2, 2, 2],
          },
        ];

        amountRow = [
          {
            text: "0",

            fontSize: 7,

            bold: true,

            alignment: "center",

            margin: [2, 2, 2, 2],
          },
        ];
      }

      console.log("Header row length:", headerRow.length);

      console.log("Amount row length:", amountRow.length);

      console.log("Header row contents:", headerRow);

      console.log("Amount row contents:", amountRow);

      console.log(
        "Creating absence table with colSpan:",

        Math.max(1, headerRow.length),
      );

      // Validate and clean headerRow and amountRow to ensure no undefined cells

      headerRow = headerRow.filter(
        (cell) => cell !== undefined && cell !== null,
      );

      amountRow = amountRow.filter(
        (cell) => cell !== undefined && cell !== null,
      );

      // Ensure rows have at least one cell

      if (headerRow.length === 0) {
        headerRow = [
          {
            text: "Summe",

            fontSize: 7,

            bold: true,

            alignment: "center",

            fillColor: "#e0e0e0",

            margin: [1, 1, 1, 1],
          },
        ];
      }

      if (amountRow.length === 0) {
        amountRow = [
          {
            text: "0",

            fontSize: 7,

            bold: true,

            alignment: "center",

            margin: [1, 1, 1, 1],
          },
        ];
      }

      console.log("After validation - Header row length:", headerRow.length);

      console.log("After validation - Amount row length:", amountRow.length);

      // Build the absence table title row with proper cell count

      const titleRowCellCount = Math.max(1, headerRow.length);

      const titleRow = [
        {
          text: `Abwesenheiten bis ${monthLabel}`,

          colSpan: titleRowCellCount,

          alignment: "center",

          fontSize: 7,

          bold: true,

          fillColor: "#d9edf7",

          margin: [1, 1, 1, 1],
        },
      ];

      // Add empty cells for remaining columns (colSpan requires actual cells)

      for (let i = 1; i < titleRowCellCount; i++) {
        titleRow.push({ text: "" });
      }

      console.log("Title row cells:", titleRow.length);

      console.log("Title row contents:", titleRow);

      columns = [
        {
          width: "*",

          table: { body: employmentRows, widths: ["*", "*", "*"] },

          layout: "noBorders",
        },

        {
          width: "auto",

          table: {
            body: [
              [
                {
                  table: {
                    body: [titleRow, headerRow, amountRow],
                  },

                  layout: {
                    hLineWidth: (i) => (i === 0 || i === 3 ? 0.5 : 0.25),

                    vLineWidth: () => 0.25,

                    hLineColor: () => "#cccccc",

                    vLineColor: () => "#cccccc",

                    paddingLeft: () => 2,

                    paddingRight: () => 2,

                    paddingTop: () => 1,

                    paddingBottom: () => 1,
                  },

                  border: [false, false, false, false],
                },
              ],
            ],
          },

          layout: "noBorders",

          margin: [10, 0, 0, 0],
        },
      ];

      // Estimate height of absence table (header + codes + amounts ~ 3 rows at ~10px) to negate bottom space

      const baseRows = 2; // employment rows

      const absenceRows = 3; // title + header + values

      const lineHeightApprox = 11;

      const estimatedHeight = (baseRows - 1) * lineHeightApprox; // only second row pushes

      return { columns, margin: [0, 0, 0, -estimatedHeight] };
    } else {
      columns = [
        {
          width: "*",

          table: { body: employmentRows, widths: ["*", "*", "*"] },

          layout: "noBorders",
        },
      ];
    }

    return { columns };
  }

  /**
   * Create agreement section with date
   */

  createAgreementSection(agreement) {
    return {
      text: [
        {
          text: "Zielvereinbarung ",

          fontSize: 14,

          bold: true,

          color: this.config.companyColors.primary,
        },

        {
          text: agreement.date,

          fontSize: 14,

          bold: true,

          color: this.config.companyColors.primary,

          margin: [0, 4, 0, 0],
        },
      ],

      // Reduced top margin to pull section closer to employee info block

      margin: [0, 4, 0, 12],
    };
  }

  /**
   * Create agreement text section
   */

  createAgreementText(agreement, specialActivities = []) {
    // Calculate total target appointments including vacation

    const baseTargetAppointments = agreement.targetAppointments || 0;

    const vacationEntry = specialActivities.find((a) => a.isVacation);

    const vacationAppointments = vacationEntry ? vacationEntry.appointments : 0;

    const totalTargetAppointments =
      baseTargetAppointments + vacationAppointments;

    return {
      stack: [
        {
          text: [
            { text: "1.) ", bold: true },

            "Nachfolgend vereinbaren wir für den oben genannten Zeitraum:",

            {
              text: "                     Termine Ist: ",

              fontSize: 9,

              width: "auto",
            },

            {
              text: totalTargetAppointments.toString(),

              fontSize: 9,

              width: "auto",

              bold: true,

              margin: [10, 0, 0, 0],
            },
          ],

          fontSize: 9,
        },

        {
          text: "abzüglich der Absagen. Die Termine müssen unseren Qualitätskriterien wie folgt entsprechen: Der Kunde muss Interesse und Bedarf an dem Auftraggeber Angebot haben.",

          fontSize: 9,

          alignment: "justify",

          margin: [0, 0, 0, 10],
        },

        {
          text: [
            {
              text: [
                { text: "2.) ", bold: true },

                "Und zusätzlich für min. 32 Aktivitäten Ist: ",
              ],

              fontSize: 9,

              margin: [0, 0, 0, 8],
            },

            {
              text:
                "          " + agreement.targetActivities?.toString() ||
                "0" + "          ",

              fontSize: 9,

              bold: true,

              margin: [0, 0, 0, 8],
            },

            {
              text: '          im Durchschnitt je Arbeitsstunde (Summe aus Anzahl Anrufe lt. Telefonanlage (doppelt gewertet)), Terminbestätigungen, qualifizieren von Daten bei Accounts, Entscheidern, Terminen/Opportunities) in dem oben genannten Zeitraum nachweislich selbst durchgeführt haben und diese mit allen relevanten Informationen im Datenbank-System vollständig dokumentiert haben, alternativ für Mitarbeiter in „service24" wenn im Durchschnitt 10 Anrufe je A-Std.',

              fontSize: 9,

              alignment: "justify",

              margin: [0, 0, 0, 8],
            },
          ],

          margin: [0, 0, 0, 10],
        },

        {
          text: [
            {
              text: `${agreement.actualCalls || "0"}`,

              fontSize: 9,

              alignment: "center",

              bold: true,

              margin: [15, 0, 0, 15],
            },

            {
              text: ` Ist (Anrufe je Stunde) lt. Telefonanlage durchgeführt.`,

              fontSize: 9,

              alignment: "center",

              margin: [15, 0, 0, 15],
            },
          ],

          margin: [10, 0, 0, 10],
        },

        {
          text: [
            {
              text: "Es gilt das wir Kunden, um Sie nicht zu belästigen, höchstens 1-2x pro Tag telefonisch kontaktieren.",

              margin: [15, 0, 0, 15],
            },
          ],
        },

        {
          text: "Prämienvereinbarung",

          fontSize: 14,

          bold: true,

          color: this.config.companyColors.primary,

          margin: [0, 8, 0, 8],
        },

        {
          text: "Sie erhalten eine Prämie je vereinbartem Termin, abzüglich der Absagen. Die Höhe der Prämie richtet sich dynamisch an der Erfolgsquote eines Projektes. Somit ist gewährleistet, dass bei unterschiedlichem Terminerfolg, jeder Mitarbeiter die gleichen Erfolgsaussichten hat. Urlaubstage werden mit der Anzahl Termine, aus dem gleichen Zeitraum unmittelbar davor, berücksichtigt. Die Prämie verdoppelt sich, wenn die Zielvereinbarung 1.) und 2.) überschritten ist.",

          fontSize: 9,

          alignment: "justify",

          margin: [0, 0, 0, 10],
        },

        {
          text: "Die Auszahlung der Erfolgsprämie erfolgt mit der Abrechnung im Folgemonat. Voraussetzung für die Erlangung der Prämie ist ein ungekündigtes Arbeitsverhältnis, eine anteilige Abrechnung der Prämie ist ausgeschlossen.",

          fontSize: 9,

          alignment: "justify",

          margin: [0, 0, 0, 10],
        },

        {
          text: "Wir wünschen Ihnen viel Erfolg zur Erreichung der Ziele.",

          fontSize: 9,

          margin: [0, 0, 0, 15],
        },
      ],

      margin: [0, 0, 0, 15],
    };
  }

  /**
   * Create signatures section
   */

  createSignaturesSection() {
    return {
      columns: [
        {
          width: "45%",

          stack: [
            {
              canvas: [
                {
                  type: "line",

                  x1: 0,

                  y1: 0,

                  x2: 180,

                  y2: 0,

                  lineWidth: 1,

                  lineColor: "#333333",
                },
              ],

              margin: [0, 0, 0, 8],
            },

            {
              text: "Vorgesetzter Projektleiter",

              fontSize: 9,

              color: this.config.companyColors.secondary,

              alignment: "left",
            },
          ],
        },

        {
          width: "10%",

          text: "",
        },

        {
          width: "45%",

          stack: [
            {
              canvas: [
                {
                  type: "line",

                  x1: 0,

                  y1: 0,

                  x2: 180,

                  y2: 0,

                  lineWidth: 1,

                  lineColor: "#333333",
                },
              ],

              margin: [0, 0, 0, 8],
            },

            {
              text: "Einverstanden                    Datum",

              fontSize: 9,

              color: this.config.companyColors.secondary,

              alignment: "left",
            },
          ],
        },
      ],
    };
  }

  /**
   * Create projects table with totals (from app.js structure)
   */

  createProjectsTable(
    projects,

    specialActivities,

    projectPremiumsByHours,

    totals,

    specialTotals,

    premiums,

    employee,
  ) {
    // Create table body using similar structure to app.js

    const tableBody = this.createTableBody(
      projects,

      totals,

      specialActivities,

      specialTotals,

      projectPremiumsByHours,

      employee,
    );

    return {
      stack: [
        {
          text: `${premiums?.tenPercent || 0}`,

          fontSize: 9,

          alignment: "right",

          color: "#666666",

          margin: [0, 0, 0, 8],
        },

        {
          table: {
            headerRows: 1,

            widths: ["40%", "12%", "12%", "18%", "18%"],

            body: tableBody,
          },

          layout: {
            hLineWidth: function (i, node) {
              return i === 0 || i === 1 ? 1 : 0.5;
            },

            vLineWidth: function (i, node) {
              return 0.5;
            },

            hLineColor: function (i, node) {
              return "#333333";
            },

            vLineColor: function (i, node) {
              return "#333333";
            },

            paddingLeft: function (i, node) {
              return 4;
            },

            paddingRight: function (i, node) {
              return 4;
            },

            paddingTop: function (i, node) {
              return 3;
            },

            paddingBottom: function (i, node) {
              return 3;
            },

            fillColor: function (i, node) {
              return i === 0 ? "#f0f0f0" : null;
            },
          },

          margin: [0, 0, 0, 20],
        },
      ],
    };
  }

  /**
   * Create table body for projects table
   */

  createTableBody(
    projects,

    totals,

    specialActivities = [],

    specialTotals = null,

    projectPremiumsByHours = [],

    employee = null,
  ) {
    const tableBody = [];

    // Header row

    tableBody.push([
      {
        text: "Projekt und Prämien Tabelle",

        fontSize: 9,

        bold: true,

        fillColor: this.config.companyColors.background,

        margin: [1, 1, 1, 1],

        alignment: "left",
      },

      {
        text: "Vereinbart",

        fontSize: 9,

        bold: true,

        fillColor: this.config.companyColors.background,

        margin: [1, 1, 1, 1],

        alignment: "center",
      },

      {
        text: "Abgesagt",

        fontSize: 9,

        bold: true,

        fillColor: this.config.companyColors.background,

        margin: [1, 1, 1, 1],

        alignment: "center",
      },

      {
        text: "Prämie je Termin",

        fontSize: 9,

        bold: true,

        fillColor: this.config.companyColors.background,

        margin: [1, 1, 1, 1],

        alignment: "center",
      },

      {
        text: "Prämie",

        fontSize: 9,

        bold: true,

        fillColor: this.config.companyColors.background,

        margin: [1, 1, 1, 1],

        alignment: "right",
      },
    ]);

    // Project rows

    projects.forEach((project) => {
      tableBody.push([
        {
          text: project.name || "",

          fontSize: 9,

          margin: [1, 1, 1, 1],
        },

        {
          text: (project.appointments || 0).toString(),

          fontSize: 9,

          alignment: "center",

          margin: [1, 1, 1, 1],
        },

        {
          text: (project.cancellations || 0).toString(),

          fontSize: 9,

          alignment: "center",

          margin: [1, 1, 1, 1],
        },

        {
          text: `${project.premiumPerAppointment || 0} €`,

          fontSize: 9,

          alignment: "center",

          margin: [1, 1, 1, 1],
        },

        {
          text: `${KRAUSSPDFGenerator.formatPremiumAmount(project.premium, project.premiumPerAppointment)} €`,

          fontSize: 9,

          alignment: "right",

          margin: [1, 1, 1, 1],
        },
      ]);
    });

    // Add dynamic "zzgl. Abgeltung Urlaub" row !before! Zwischensumme (only if vacation entry exists)

    const vacationEntry = specialActivities.find((a) => a.isVacation);

    if (vacationEntry) {
      // Calculate vacation days from employee absence summary (type "Urlaub")

      let vacationDays = 0;

      if (employee && employee.absenceSummary) {
        vacationDays = employee.absenceSummary

          .filter((a) => a.type === "Urlaub")

          .reduce((sum, a) => sum + (a.amount || 0), 0);
      }

      console.log(vacationEntry, "vacationEntry");

      console.log(
        "Calculated vacation days from absence summary:",
        vacationDays,
      );

      // Format vacation days text

      const vacationDaysText =
        vacationDays > 0 ? ` (${vacationDays.toFixed(1)} Tage)` : "";

      tableBody.push([
        {
          text: `zzgl. Abgeltung Urlaub`,

          fontSize: 9,

          margin: [1, 1, 1, 1],
        },

        {
          text: vacationEntry.appointments.toString(),

          fontSize: 9,

          alignment: "center",

          margin: [1, 1, 1, 1],
        },

        {
          text: vacationEntry.cancellations.toString(),

          fontSize: 9,

          alignment: "center",

          margin: [1, 1, 1, 1],
        },

        {
          text: `${vacationEntry.premiumPerAppointment} €`,

          fontSize: 9,

          alignment: "center",

          margin: [1, 1, 1, 1],
        },

        {
          text: `${KRAUSSPDFGenerator.formatPremiumAmount(vacationEntry.premium, vacationEntry.premiumPerAppointment)} €`,

          fontSize: 9,

          alignment: "right",

          margin: [1, 1, 1, 1],
        },
      ]);
    }

    // Subtotal row (Zwischensumme) now includes vacation entry values if present

    const subtotalAppointments =
      (totals?.appointments || 0) +
      (vacationEntry ? vacationEntry.appointments : 0);

    const subtotalCancellations =
      (totals?.cancellations || 0) +
      (vacationEntry ? vacationEntry.cancellations : 0);

    const subtotalPremium =
      (totals?.premium || 0) + (vacationEntry ? vacationEntry.premium : 0);

    tableBody.push([
      {
        text: "Zwischensumme",

        fontSize: 9,

        bold: true,

        margin: [1, 1, 1, 1],

        fillColor: "#f0f0f0",

        border: [true, true, true, true],

        borderColor: ["#000000", "#000000", "#000000", "#000000"],

        borderWidth: [1, 1, 1, 1],
      },

      {
        text: subtotalAppointments.toString(),

        fontSize: 9,

        bold: true,

        alignment: "center",

        margin: [1, 1, 1, 1],

        fillColor: "#f0f0f0",

        border: [true, true, true, true],

        borderColor: ["#000000", "#000000", "#000000", "#000000"],

        borderWidth: [1, 1, 1, 1],
      },

      {
        text: subtotalCancellations.toString(),

        fontSize: 9,

        bold: true,

        alignment: "center",

        margin: [1, 1, 1, 1],

        fillColor: "#f0f0f0",

        border: [true, true, true, true],

        borderColor: ["#000000", "#000000", "#000000", "#000000"],

        borderWidth: [1, 1, 1, 1],
      },

      {
        text: "",

        fontSize: 9,

        bold: true,

        margin: [1, 1, 1, 1],

        fillColor: "#f0f0f0",

        border: [true, true, true, true],

        borderColor: ["#000000", "#000000", "#000000", "#000000"],

        borderWidth: [1, 1, 1, 1],
      },

      {
        text: `${KRAUSSPDFGenerator.formatPremiumAmount(subtotalPremium, undefined)} €`,

        fontSize: 9,

        bold: true,

        alignment: "right",

        margin: [1, 1, 1, 1],

        fillColor: "#f0f0f0",

        border: [true, true, true, true],

        borderColor: ["#000000", "#000000", "#000000", "#000000"],

        borderWidth: [1, 1, 1, 1],
      },
    ]);

    // Spacer row

    const spacerRow = [
      {
        text: "",

        colSpan: 5,

        border: [false, false, false, false],

        margin: [0, 1, 0, 1],
      },

      { text: "", border: [false, false, false, false] },

      { text: "", border: [false, false, false, false] },

      { text: "", border: [false, false, false, false] },

      { text: "", border: [false, false, false, false] },
    ];

    tableBody.push(spacerRow);

    // Special actions header

    tableBody.push([
      {
        text: "zzgl. Sonderaktion",

        fontSize: 9,

        bold: true,

        margin: [1, 1, 1, 1],
      },

      { text: "", fontSize: 9, margin: [1, 1, 1, 1] },

      { text: "", fontSize: 9, margin: [1, 1, 1, 1] },

      { text: "", fontSize: 9, margin: [1, 1, 1, 1] },

      { text: "", fontSize: 9, margin: [1, 1, 1, 1] },
    ]);

    // Special activities rows (dynamic from query45)

    if (specialActivities && specialActivities.length > 0) {
      specialActivities

        .filter((a) => !a.isVacation) // skip vacation (already rendered above)
        .forEach((activity) => {
          tableBody.push([
            { text: activity.name, fontSize: 9, margin: [1, 1, 1, 1] },

            {
              text: activity.appointments.toString(),

              fontSize: 9,

              alignment: "center",

              margin: [1, 1, 1, 1],
            },

            {
              text: activity.cancellations.toString(),

              fontSize: 9,

              alignment: "center",

              margin: [1, 1, 1, 1],
            },

            {
              text: `${activity.premiumPerAppointment} €`,

              fontSize: 9,

              alignment: "center",

              margin: [1, 1, 1, 1],
            },

            {
              text: `${KRAUSSPDFGenerator.formatPremiumAmount(activity.premium, activity.premiumPerAppointment)} €`,

              fontSize: 9,

              alignment: "right",

              margin: [1, 1, 1, 1],
            },
          ]);
        });
    } else {
      // Fallback to show no special activities

      tableBody.push([
        { text: "Keine Sonderaktionen", fontSize: 9, margin: [1, 1, 1, 1] },

        { text: "0", fontSize: 9, alignment: "center", margin: [1, 1, 1, 1] },

        { text: "0", fontSize: 9, alignment: "center", margin: [1, 1, 1, 1] },

        { text: "0 €", fontSize: 9, alignment: "center", margin: [1, 1, 1, 1] },

        { text: "0 €", fontSize: 9, alignment: "right", margin: [1, 1, 1, 1] },
      ]);
    }

    // Project premiums by hours rows (dynamic from query47)

    if (projectPremiumsByHours && projectPremiumsByHours.length > 0) {
      // Another spacer

      tableBody.push(spacerRow);

      projectPremiumsByHours.forEach((projectPremium) => {
        tableBody.push([
          {
            text: projectPremium.name,

            fontSize: 9,

            margin: [1, 1, 1, 1],
          },

          {
            text: Math.round(projectPremium.hoursWorked).toString(),

            fontSize: 9,

            alignment: "center",

            margin: [1, 1, 1, 1],
          },

          {
            text: "-",

            fontSize: 9,

            alignment: "center",

            margin: [1, 1, 1, 1],
          },

          {
            text: `${projectPremium.premiumPerHour} €/h`,

            fontSize: 9,

            alignment: "center",

            margin: [1, 1, 1, 1],
          },

          {
            text: `${KRAUSSPDFGenerator.formatPremiumAmount(projectPremium.totalPremium, projectPremium.premiumPerHour)} €`,

            fontSize: 9,

            alignment: "right",

            margin: [1, 1, 1, 1],
          },
        ]);
      });
    }

    // Another spacer

    tableBody.push(spacerRow);

    // Total row (including special activities and project premiums by hours)

    const projectPremiumsByHoursTotal = projectPremiumsByHours.reduce(
      (sum, p) => sum + p.totalPremium,

      0,
    );

    const grandTotal =
      (totals?.premium || 0) +
      (specialTotals?.premium || 0) +
      projectPremiumsByHoursTotal;

    tableBody.push([
      {
        text: "Gesamt",

        fontSize: 9,

        bold: true,

        margin: [1, 1, 1, 1],

        fillColor: "#f0f0f0",

        border: [true, true, true, true],

        borderColor: ["#000000", "#000000", "#000000", "#000000"],

        borderWidth: [1, 1, 1, 1],
      },

      {
        text: "",

        fontSize: 9,

        margin: [1, 1, 1, 1],

        fillColor: "#f0f0f0",

        border: [true, true, true, true],

        borderColor: ["#000000", "#000000", "#000000", "#000000"],

        borderWidth: [1, 1, 1, 1],
      },

      {
        text: "",

        fontSize: 9,

        margin: [1, 1, 1, 1],

        fillColor: "#f0f0f0",

        border: [true, true, true, true],

        borderColor: ["#000000", "#000000", "#000000", "#000000"],

        borderWidth: [1, 1, 1, 1],
      },

      {
        text: "",

        fontSize: 9,

        margin: [1, 1, 1, 1],

        fillColor: "#f0f0f0",

        border: [true, true, true, true],

        borderColor: ["#000000", "#000000", "#000000", "#000000"],

        borderWidth: [1, 1, 1, 1],
      },

      {
        text: `${KRAUSSPDFGenerator.formatPremiumAmount(grandTotal, undefined)} €`,

        fontSize: 9,

        bold: true,

        alignment: "right",

        margin: [1, 1, 1, 1],

        fillColor: "#f0f0f0",

        border: [true, true, true, true],

        borderColor: ["#000000", "#000000", "#000000", "#000000"],

        borderWidth: [1, 1, 1, 1],
      },
    ]);

    return tableBody;
  }

  /**
   * Generate filename from worker data
   */

  generateFilename(workerData, template = null) {
    const employeeName = workerData.employee?.name || "Unknown";

    const date = getSafeDate("YYYY-MM");

    if (template) {
      return template.replace(/[^a-zA-Z0-9._-]/g, "_");
    }

    return `${employeeName.replace(/\s+/g, "_")}_Zielvereinbarung_${date}.pdf`;
  }

  /**
   * Format date for German locale
   */

  static formatDate(date, format = "DD.MM.YYYY", locale = "de") {
    if (!date) return "";

    // Try to use moment.js if available

    if (typeof moment !== "undefined") {
      moment.locale(locale);

      return moment(date).format(format);
    }

    // Fallback to native Date formatting

    const dateObj = typeof date === "string" ? new Date(date) : date;

    if (locale === "de" && format === "DD.MM.YYYY") {
      return dateObj.toLocaleDateString("de-DE");
    }

    return dateObj.toLocaleDateString();
  }

  /**
   * Transform API data from Retool query format to document template format
   * @param {Object} apiWorkerData - Raw API data for a worker from Retool
   * @param {Object} query41Data - Premium per project data from query41
   * @param {Object} query45Data - Premium per activity type data from query45
   * @param {Object} query47Data - Premium per project hours data from query47
   * @param {Object} query50Data - Special liveshow premiums data from query50
   * @param {Array} allWorkerData - All worker data for global calculations (optional)
   * @param {Array} getDurchGefuehrteLSData - Direct getDurchGefuehrteLS data for global liveshow calculation (optional)
   * @param {Array} query53Data - Absence code mapping data from query53 (optional)
   * @returns {Object} Transformed data ready for document generation
   */

  static transformAPIData(
    apiWorkerData,

    query41Data = null,

    query45Data = null,

    query47Data = null,

    query50Data = null,

    allWorkerData = null,

    getDurchGefuehrteLSData = null,

    query53Data = null,
  ) {
    if (!apiWorkerData) {
      throw new Error("No worker data provided");
    }

    // Calculate working hours from duration (handle both seconds and hours)

    let workingHoursTotal = 0;

    if (apiWorkerData.duration) {
      // If duration is very large (>1000), it's likely in seconds, convert to hours

      // If duration is small (<1000), it's likely already in hours

      workingHoursTotal =
        apiWorkerData.duration > 1000
          ? apiWorkerData.duration / 3600 // Convert seconds to hours
          : apiWorkerData.duration; // Already in hours
    }

    // Calculate calls per hour

    const totalCalls = Array.isArray(apiWorkerData.calls)
      ? apiWorkerData.calls.length
      : apiWorkerData.calls || 0;

    const callsPerHour =
      workingHoursTotal > 0 ? totalCalls / workingHoursTotal : 0;

    // Calculate termine (billed activities - canceled activities)

    // Subtract liveshow-related activities to avoid double counting in normal section

    const totalBilled = apiWorkerData.total_billed || 0;

    const totalBilledFromLS = apiWorkerData.total_billed_out_of_ls || 0;

    const totalCanceled = apiWorkerData.total_canceled || 0;

    const totalCanceledFromLS = apiWorkerData.total_canceled_out_of_ls || 0;

    // Normal activities = total activities - liveshow activities

    const normalBilled = totalBilled - totalBilledFromLS;

    const normalCanceled = totalCanceled - totalCanceledFromLS;

    // Liveshow activities (net: billed - canceled)

    const liveshowTermine = totalBilledFromLS - totalCanceledFromLS;

    // Total termine = normal activities + liveshow activities

    const termine = normalBilled - normalCanceled + liveshowTermine;

    // Calculate activities per hour (enhanced calculation)

    const totalQualified = apiWorkerData.total_qualified || 0;

    const totalQualifiedContacts = apiWorkerData.total_qualified_contacts || 0;

    // If no qualified companies and no qualified contacts, set average activities to 0

    const activitiesPerHour =
      (totalQualified === 0 && totalQualifiedContacts === 0) ||
      workingHoursTotal <= 0
        ? 0
        : (totalCalls * 2 +
            normalBilled -
            normalCanceled +
            totalQualified +
            totalQualifiedContacts) /
          workingHoursTotal;

    console.log(
      "=== WORKER DATA ANALYSIS ===",

      "\nWorker name:",

      apiWorkerData.name,

      "\nRaw duration (seconds):",

      apiWorkerData.duration,

      "\nWorking hours total (hours):",

      workingHoursTotal,

      "\nContract working_hours:",

      apiWorkerData.working_hours,

      "\nTotal calls:",

      totalCalls,

      "\nCalls per hour:",

      callsPerHour,

      "\nTotal billed:",

      totalBilled,

      "\nTotal canceled:",

      totalCanceled,

      "\nTotal qualified:",

      totalQualified,

      "\nTotal qualified contacts:",

      totalQualifiedContacts,

      "\nActivities per hour:",

      activitiesPerHour,

      "\n==========================",
    );

    // Calculate 10% premium: working_hours * 4 weeks * 17 euros * 0.1

    const workingHoursContract = apiWorkerData.working_hours || 0; // Remove division by 4

    const tenPercentPremium = workingHoursContract * 4 * 17 * 0.1;

    // Transform projects data with premium information from query41

    const projects = this.processProjectsData(
      apiWorkerData,

      query41Data,

      query50Data,
    );

    // Process special activities with premium information from query45

    const specialActivities = this.processSpecialActivities(
      apiWorkerData,

      query45Data,
    );

    // Calculate project premiums by hours using query47Data

    const projectPremiumsByHours = this.calculateProjectPremiumsByHours(
      apiWorkerData,

      query47Data,
    );

    // Calculate liveshow special premiums using query50Data

    const liveshowPremiums = this.calculateLiveshowPremiums(
      apiWorkerData,

      query50Data,

      allWorkerData,

      getDurchGefuehrteLSData,
    );

    // Combine special activities with liveshow premiums

    let allSpecialActivities = [...specialActivities, ...liveshowPremiums];

    // Vacation (Urlaub) premium logic: Show if either:

    // 1. total_premium_activities > 0 (vacation appointments were made), OR

    // 2. Worker has absences in the month (absence_summary has entries)

    try {
      const totalPremiumActivities =
        apiWorkerData.total_premium_activities || 0;

      const hasAbsences =
        Array.isArray(apiWorkerData.absence_summary) &&
        apiWorkerData.absence_summary.length > 0;

      if (totalPremiumActivities > 0 || hasAbsences) {
        // Collect premium per appointment values ONLY from projects (exclude special & liveshow premiums)

        const premiumCandidates = projects

          .filter((p) => typeof p.premiumPerAppointment === "number")

          .map((p) => p.premiumPerAppointment);

        const highestPremium =
          premiumCandidates.length > 0 ? Math.max(...premiumCandidates) : 0;

        // Always show vacation entry if there are absences, even with 0 premium

        const vacationPremiumEntry = {
          name: "zzgl. Abgeltung Urlaub",

          appointments: totalPremiumActivities, // count of activities considered for vacation compensation

          cancellations: 0,

          premiumPerAppointment: highestPremium,

          premium: totalPremiumActivities * highestPremium,

          isVacation: true,
        };

        allSpecialActivities.push(vacationPremiumEntry);

        if (hasAbsences && totalPremiumActivities === 0) {
          console.log(
            `ℹ️ Showing vacation entry for ${apiWorkerData.name} due to absences (${apiWorkerData.absence_summary.length} absence codes), even though total_premium_activities = 0`,
          );
        }
      }
    } catch (e) {
      console.warn("Urlaub premium calculation failed:", e);
    }

    // Calculate totals (including special activities)

    const totals = {
      appointments: projects.reduce((sum, p) => sum + p.appointments, 0),

      cancellations: projects.reduce((sum, p) => sum + p.cancellations, 0),

      premium: projects.reduce((sum, p) => sum + p.premium, 0),
    };

    const specialTotals = {
      appointments: allSpecialActivities.reduce(
        (sum, a) => sum + a.appointments,

        0,
      ),

      cancellations: allSpecialActivities.reduce(
        (sum, a) => sum + a.cancellations,

        0,
      ),

      premium: allSpecialActivities.reduce((sum, a) => sum + a.premium, 0),
    };

    // Debug absence data

    console.groupCollapsed(`🔴 Absence Data: ${apiWorkerData.name}`);

    console.assert(query53Data, "query53Data (absence codes) not available!");

    // Create code-to-type mapping from query53 if available

    let codeToTypeMap = {};

    if (query53Data && Array.isArray(query53Data)) {
      query53Data.forEach((item) => {
        if (item.code && item.type) {
          codeToTypeMap[item.code] = item.type;
        }
      });

      console.log(
        `✅ Mapped ${Object.keys(codeToTypeMap).length} absence codes`,
      );
    } else {
      console.warn("query53Data unavailable - cannot map absence types");
    }

    const processedAbsenceSummary = Array.isArray(apiWorkerData.absence_summary)
      ? apiWorkerData.absence_summary.map((a) => {
          const mappedType = codeToTypeMap[a.code];

          const finalType = mappedType || a.type || a.code || "Unbekannt";

          return {
            code: a.code,

            amount: a.amount,

            type: finalType,
          };
        })
      : [];

    if (processedAbsenceSummary.length > 0) {
      console.table(processedAbsenceSummary);

      console.log(`Total Fehltage: ${apiWorkerData.total_fehltage || 0}`);
    } else {
      console.log("No absence data");
    }

    console.groupEnd();

    return {
      employee: {
        name: apiWorkerData.name || "Unknown",

        startDate: this.formatDate(apiWorkerData.start_date) || "-",

        endDate:
          this.formatDate(
            apiWorkerData.probezeitende ||
              apiWorkerData.end_date ||
              (apiWorkerData.start_date
                ? moment(apiWorkerData.start_date)

                    .add(6, "months")

                    .add(-1, "days")

                    .format("YYYY-MM-DD")
                : null),
          ) || "-",

        workingHours: workingHoursContract, // Use contract hours directly (likely already weekly)

        istWorkingHours: this.roundToTwoDecimals(workingHoursTotal), // Actual worked hours in selected period (A-Std.)

        sollWorkingHours: this.roundToTwoDecimals(workingHoursContract * 4), // Contract weekly hours * 4 weeks

        // Absence summary (codes with amounts) and total missing days if provided by query43

        absenceSummary: processedAbsenceSummary,

        totalFehltage: apiWorkerData.total_fehltage || 0,
      },

      agreement: {
        date: (() => {
          if (dateRangeSelector?.value?.start) {
            return dateRangeSelector.value.start

              .locale("de")

              .format("MMMM YYYY");
          } else if (typeof moment !== "undefined") {
            return moment().locale("de").format("MMMM YYYY");
          } else {
            const now = new Date();

            const months = [
              "Januar",

              "Februar",

              "März",

              "April",

              "Mai",

              "Juni",

              "Juli",

              "August",

              "September",

              "Oktober",

              "November",

              "Dezember",
            ];

            return `${months[now.getMonth()]} ${now.getFullYear()}`;
          }
        })(),

        targetAppointments: termine,

        targetActivities: Math.round(activitiesPerHour),

        actualCalls: Math.round(callsPerHour),
      },

      projects: projects,

      specialActivities: allSpecialActivities,

      projectPremiumsByHours: projectPremiumsByHours,

      totals: totals,

      specialTotals: specialTotals,

      premiums: {
        tenPercent: this.roundToTwoDecimals(tenPercentPremium),
      },

      statistics: {
        workingHoursTotal: this.roundToTwoDecimals(workingHoursTotal),

        callsPerHour: this.roundToTwoDecimals(callsPerHour),

        activitiesPerHour: this.roundToTwoDecimals(activitiesPerHour),

        reachability: this.toPercentage(apiWorkerData.reachability),

        conversionRate: this.toPercentage(apiWorkerData.conversionRate),
      },
    };
  }

  /**
   * Process projects data from API format
   * @param {Object} apiWorkerData - Raw API worker data
   * @param {Object} query41Data - Premium per project data from query41
   * @param {Object} query50Data - Liveshow premium data from query50
   * @returns {Array} Processed projects array
   */

  static processProjectsData(
    apiWorkerData,

    query41Data = null,

    query50Data = null,
  ) {
    const projects = [];

    // Helper function to safely get activities array

    const getActivities = (activities) =>
      Array.isArray(activities) ? activities : [];

    // Check if worker is assigned to any liveshow premium groups

    const isWorkerInLiveshowGroups =
      KRAUSSPDFGenerator.isWorkerInLiveshowGroups(apiWorkerData, query50Data);

    console.log(
      `Worker ${apiWorkerData.name} is in liveshow groups: ${isWorkerInLiveshowGroups}`,
    );

    // Only apply liveshow exclusions if worker is in liveshow groups

    let liveshowBilledCounts = {};

    let liveshowCanceledCounts = {};

    if (isWorkerInLiveshowGroups) {
      // Get liveshow activities to exclude from normal projects

      const liveshowBilledActivities = getActivities(
        apiWorkerData.billed_activities_out_of_ls,
      );

      const liveshowCanceledActivities = getActivities(
        apiWorkerData.canceled_activities_out_of_ls,
      );

      // Create maps of liveshow activity counts for exclusion

      liveshowBilledActivities.forEach((activity) => {
        const key = `${activity.projectName}_${activity.type}`;

        liveshowBilledCounts[key] =
          (liveshowBilledCounts[key] || 0) + (activity.recordCount || 0);
      });

      liveshowCanceledActivities.forEach((activity) => {
        const key = `${activity.projectName}_${activity.type}`;

        liveshowCanceledCounts[key] =
          (liveshowCanceledCounts[key] || 0) + (activity.recordCount || 0);
      });
    }

    // Group billed activities by projectName and type (subtracting liveshow activities)

    const billedByProject = {};

    getActivities(apiWorkerData.billed_activities).forEach((activity) => {
      const key = `${activity.projectName}_${activity.type}`;

      if (!billedByProject[key]) {
        billedByProject[key] = {
          projectName: activity.projectName,

          type: activity.type,

          count: 0,
        };
      }

      billedByProject[key].count += activity.recordCount || 0;
    });

    // Subtract liveshow counts from billed activities (only if worker is in liveshow groups)

    if (isWorkerInLiveshowGroups) {
      Object.keys(liveshowBilledCounts).forEach((key) => {
        if (billedByProject[key]) {
          billedByProject[key].count -= liveshowBilledCounts[key];

          console.log(
            `Subtracting ${liveshowBilledCounts[key]} liveshow billed activities from ${key}. New count: ${billedByProject[key].count}`,
          );

          // Remove if count becomes zero or negative

          if (billedByProject[key].count <= 0) {
            delete billedByProject[key];
          }
        }
      });
    }

    // Group canceled activities by projectName and type (subtracting liveshow activities)

    const canceledByProject = {};

    getActivities(apiWorkerData.canceled_activities).forEach((activity) => {
      const key = `${activity.projectName}_${activity.type}`;

      if (!canceledByProject[key]) {
        canceledByProject[key] = {
          projectName: activity.projectName,

          type: activity.type,

          count: 0,
        };
      }

      canceledByProject[key].count += activity.recordCount || 0;
    });

    // Subtract liveshow counts from canceled activities (only if worker is in liveshow groups)

    if (isWorkerInLiveshowGroups) {
      Object.keys(liveshowCanceledCounts).forEach((key) => {
        if (canceledByProject[key]) {
          canceledByProject[key].count -= liveshowCanceledCounts[key];

          console.log(
            `Subtracting ${liveshowCanceledCounts[key]} liveshow canceled activities from ${key}. New count: ${canceledByProject[key].count}`,
          );

          // Remove if count becomes zero or negative

          if (canceledByProject[key].count <= 0) {
            delete canceledByProject[key];
          }
        }
      });
    }

    // Create projects from activity data

    Object.keys(billedByProject).forEach((key) => {
      const billedActivity = billedByProject[key];

      const canceledActivity = canceledByProject[key] || { count: 0 };

      // Skip if type is missing (but allow null projectName with fallback)

      if (!billedActivity.type) {
        console.warn(
          `Skipping activity with missing type:`,

          billedActivity,
        );

        return;
      }

      // Use fallback name for activities without projectName

      const projectName = billedActivity.projectName || "Unbekanntes Projekt";

      const appointments = billedActivity.count;

      const cancellations = canceledActivity.count;

      const netAppointments = appointments - cancellations; // Allow negative values

      // Get premium per appointment - only from query41 data, default to 0

      let premiumPerAppointment = 0; // Default to 0, no fallback premium

      // Apply premium data from query41 if available

      if (query41Data) {
        const projectPremium = this.getProjectPremiumFromQuery41(
          billedActivity.projectName,

          query41Data,
        );

        if (projectPremium !== null) {
          premiumPerAppointment = projectPremium;
        }
      }

      projects.push({
        name: `${projectName} (${billedActivity.type})`,

        appointments: appointments,

        cancellations: cancellations,

        premiumPerAppointment: premiumPerAppointment,

        premium: netAppointments * premiumPerAppointment, // Can be positive or negative
      });
    });

    // Add canceled-only projects

    Object.keys(canceledByProject).forEach((key) => {
      if (!billedByProject[key]) {
        const canceledActivity = canceledByProject[key];

        // Skip if projectName or type is missing

        if (!canceledActivity.projectName || !canceledActivity.type) {
          console.warn(
            `Skipping canceled activity with missing projectName or type:`,

            canceledActivity,
          );

          return;
        }

        // Get premium for canceled-only projects - only from query41, default to 0

        let premiumPerAppointment = 0; // Default to 0, no fallback premium

        if (query41Data) {
          const projectPremium = this.getProjectPremiumFromQuery41(
            canceledActivity.projectName,

            query41Data,
          );

          if (projectPremium !== null) {
            premiumPerAppointment = projectPremium;
          }
        }

        projects.push({
          name: `${canceledActivity.projectName} (${canceledActivity.type})`,

          appointments: 0,

          cancellations: canceledActivity.count,

          premiumPerAppointment: premiumPerAppointment,

          premium: (0 - canceledActivity.count) * premiumPerAppointment, // Negative premium for cancellations only
        });
      }
    });

    return projects.sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically
  }

  /**
   * Process special activities data from API format for activity type premiums
   * @param {Object} apiWorkerData - Raw API worker data
   * @param {Object} query45Data - Premium per activity type data from query45
   * @returns {Array} Processed special activities array
   */

  static processSpecialActivities(apiWorkerData, query45Data = null) {
    const specialActivities = [];

    if (!query45Data) {
      console.log(
        "No query45 data available, skipping special activities processing",
      );

      return specialActivities;
    }

    console.log(
      "Processing special activities with query45 data:",

      query45Data,
    );

    console.log("Available activity names in query45:", query45Data.name);

    console.log("Available activity premiums in query45:", query45Data.premium);

    console.log("Checking apiWorkerData structure:");

    console.log("apiWorkerData keys:", Object.keys(apiWorkerData));

    console.log("all_billed_activities:", apiWorkerData.all_billed_activities);

    console.log(
      "all_canceled_activities:",

      apiWorkerData.all_canceled_activities,
    );

    // Helper function to safely get activities array

    const getActivities = (activities) =>
      Array.isArray(activities) ? activities : [];

    console.log(
      "Is all_billed_activities an array?",

      Array.isArray(apiWorkerData.all_billed_activities),
    );

    console.log(
      "Is all_canceled_activities an array?",

      Array.isArray(apiWorkerData.all_canceled_activities),
    );

    console.log(
      "All billed activities from apiWorkerData:",

      apiWorkerData.all_billed_activities,
    );

    console.log(
      "All canceled activities from apiWorkerData:",

      apiWorkerData.all_canceled_activities,
    );

    // Group all_billed_activities by activity type

    const billedByType = {};

    getActivities(apiWorkerData.all_billed_activities).forEach((activity) => {
      const activityType = activity.type;

      console.log(
        "Processing billed activity:",

        activity,

        "Type:",

        activityType,
      );

      if (!billedByType[activityType]) {
        billedByType[activityType] = 0;
      }

      billedByType[activityType] += activity.recordCount || 0;
    });

    // Group all_canceled_activities by activity type

    const canceledByType = {};

    getActivities(apiWorkerData.all_canceled_activities).forEach((activity) => {
      const activityType = activity.type;

      if (!canceledByType[activityType]) {
        canceledByType[activityType] = 0;
      }

      canceledByType[activityType] += activity.recordCount || 0;
    });

    // Get all unique activity types

    const allActivityTypes = new Set([
      ...Object.keys(billedByType),

      ...Object.keys(canceledByType),
    ]);

    console.log(
      "All unique activity types found:",

      Array.from(allActivityTypes),
    );

    console.log("Billed activities by type:", billedByType);

    console.log("Canceled activities by type:", canceledByType);

    // Process each activity type

    allActivityTypes.forEach((activityType) => {
      console.log(`Looking up premium for activity type: "${activityType}"`);

      const premium = getActivityTypePremiumFromQuery45(
        activityType,

        query45Data,
      );

      console.log(`Premium found for "${activityType}":`, premium);

      // Only include activities that have a premium > 0

      if (premium && premium > 0) {
        const billed = billedByType[activityType] || 0;

        const canceled = canceledByType[activityType] || 0;

        const netActivities = billed - canceled; // Can be negative

        specialActivities.push({
          name: activityType,

          appointments: billed,

          cancellations: canceled,

          premiumPerAppointment: premium,

          premium: netActivities * premium, // Can be positive or negative
        });
      }
    });

    console.log("Processed special activities:", specialActivities);

    return specialActivities.sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically
  }

  /**
   * Calculate project premiums by hours worked
   * @param {Object} apiWorkerData - Raw API worker data with duration per project
   * @param {Array} query47Data - Project data with premium per hour information
   * @returns {Array} Array of project premium by hours calculations
   */

  static calculateProjectPremiumsByHours(apiWorkerData, query47Data = null) {
    const projectPremiumsByHours = [];

    if (!query47Data || !Array.isArray(query47Data)) {
      console.log(
        "No query47 data available, skipping project premiums by hours calculation",
      );

      return projectPremiumsByHours;
    }

    console.log(
      "Processing project premiums by hours with query47 data:",

      query47Data,
    );

    // Debug: Show query47 projects that contain "Liveshow" or "vorbereitung"

    const liveshowProjects = query47Data.filter(
      (p) =>
        p.name &&
        (p.name.toLowerCase().includes("liveshow") ||
          p.name.toLowerCase().includes("vorbereitung")),
    );

    console.log("Liveshow-related projects in query47:", liveshowProjects);

    // Debug: Check the structure of apiWorkerData for children/projects

    console.log("=== CHILDREN DEBUG START ===");

    console.log("typeof apiWorkerData:", typeof apiWorkerData);

    console.log("apiWorkerData.children:", apiWorkerData.children);

    console.log("apiWorkerData['children']:", apiWorkerData["children"]);

    console.log("Has children property:", "children" in apiWorkerData);

    console.log("Object.keys(apiWorkerData):", Object.keys(apiWorkerData));

    console.log("Is children an array?", Array.isArray(apiWorkerData.children));

    if (apiWorkerData.children) {
      console.log("Children length:", apiWorkerData.children.length);

      console.log("First few children:", apiWorkerData.children.slice(0, 3));

      // Look for Liveshow Vorbereitung specifically

      const liveshowPrep = apiWorkerData.children.find(
        (child) =>
          child.name &&
          child.name.toLowerCase().includes("liveshow") &&
          child.name.toLowerCase().includes("vorbereitung"),
      );

      console.log("Found Liveshow Vorbereitung in children:", liveshowPrep);
    }

    console.log("=== CHILDREN DEBUG END ===");

    // Debug: Check for other possible project duration sources

    console.log("Other potential project data sources:");

    console.log("apiWorkerData.amounts:", apiWorkerData.amounts);

    console.log(
      "apiWorkerData.billed_activities:",

      apiWorkerData.billed_activities,
    );

    console.log(
      "apiWorkerData keys that might contain project data:",

      Object.keys(apiWorkerData).filter(
        (key) =>
          key.toLowerCase().includes("project") ||
          key.toLowerCase().includes("time") ||
          key.toLowerCase().includes("duration") ||
          key.toLowerCase().includes("hours"),
      ),
    );

    // Helper function to safely get projects array from children

    const getProjects = (children) => (Array.isArray(children) ? children : []);

    console.groupCollapsed(
      `📁 Processing ${getProjects(apiWorkerData.children).length} Projects`,
    );

    console.time("Project Processing");

    // Process each project from the children array (worked projects)

    getProjects(apiWorkerData.children).forEach((project, index) => {
      // Convert duration from seconds to hours

      const hoursWorked = project.duration / 3600;

      // Find matching project in query47Data by name (silent search)

      const matchingProject = query47Data.find(
        (p) =>
          p.name &&
          project.name &&
          p.name.toLowerCase() === project.name.toLowerCase(),
      );

      if (
        matchingProject &&
        matchingProject.premium &&
        matchingProject.premium > 0
      ) {
        const premiumPerHour = parseFloat(matchingProject.premium) || 0;

        const totalPremium = hoursWorked * premiumPerHour;

        console.log(
          `✅ ${project.name}: ${hoursWorked.toFixed(
            2,
          )}h × €${premiumPerHour} = €${totalPremium.toFixed(2)}`,
        );

        projectPremiumsByHours.push({
          name: project.name,

          hoursWorked: this.roundToTwoDecimals(hoursWorked),

          premiumPerHour: premiumPerHour,

          totalPremium: this.roundToTwoDecimals(totalPremium),
        });
      } else if (index < 3) {
        // Only log first 3 non-premium projects to reduce noise

        console.debug(`❌ No premium: ${project.name}`);
      }
    });

    console.timeEnd("Project Processing");

    if (projectPremiumsByHours.length > 0) {
      console.table(projectPremiumsByHours);
    }

    console.groupEnd();

    // Fallback: If no children data, try to match based on user type and total duration

    if (!apiWorkerData.children || apiWorkerData.children.length === 0) {
      console.log(
        "No children data found, checking for project-specific duration in other fields",
      );

      // Check if we have project duration data in amounts or other fields

      if (apiWorkerData.amounts && Array.isArray(apiWorkerData.amounts)) {
        console.log(
          "Checking amounts array for project duration data:",

          apiWorkerData.amounts,
        );

        apiWorkerData.amounts.forEach((amountEntry) => {
          console.log("Amount entry:", amountEntry);

          // Look for matching project in query47

          if (amountEntry.projectName || amountEntry.name) {
            const projectName = amountEntry.projectName || amountEntry.name;

            if (!projectName) return; // Skip if projectName is null

            const matchingProject = query47Data.find(
              (p) =>
                p.name && p.name.toLowerCase() === projectName.toLowerCase(),
            );

            if (
              matchingProject &&
              matchingProject.premium &&
              matchingProject.premium > 0
            ) {
              // Use duration from amount entry if available, or try other duration fields

              let projectDuration =
                amountEntry.duration || amountEntry.hours || amountEntry.time;

              if (projectDuration) {
                // Check if duration is in seconds and convert to hours

                const hoursWorked =
                  projectDuration > 100
                    ? projectDuration / 3600
                    : projectDuration;

                const premiumPerHour = parseFloat(matchingProject.premium) || 0;

                const totalPremium = hoursWorked * premiumPerHour;

                console.log(
                  `Found project duration in amounts: ${projectName}: ${hoursWorked.toFixed(
                    2,
                  )} hours, premium: ${premiumPerHour} EUR/hour, total: ${totalPremium.toFixed(
                    2,
                  )} EUR`,
                );

                projectPremiumsByHours.push({
                  name: projectName,

                  hoursWorked: this.roundToTwoDecimals(hoursWorked),

                  premiumPerHour: premiumPerHour,

                  totalPremium: this.roundToTwoDecimals(totalPremium),
                });
              }
            }
          }
        });
      }

      // Also check billed_activities for project-specific duration

      if (
        apiWorkerData.billed_activities &&
        Array.isArray(apiWorkerData.billed_activities)
      ) {
        console.log("Checking billed_activities for project duration data");

        // Group activities by project to get project-specific duration

        const projectDurations = {};

        apiWorkerData.billed_activities.forEach((activity) => {
          if (activity.projectName && activity.duration) {
            if (!projectDurations[activity.projectName]) {
              projectDurations[activity.projectName] = 0;
            }

            projectDurations[activity.projectName] += activity.duration;
          }
        });

        console.log(
          "Project durations from billed_activities:",

          projectDurations,
        );

        Object.keys(projectDurations).forEach((projectName) => {
          if (!projectName) return; // Skip if projectName is null/undefined

          const matchingProject = query47Data.find(
            (p) => p.name && p.name.toLowerCase() === projectName.toLowerCase(),
          );

          if (
            matchingProject &&
            matchingProject.premium &&
            matchingProject.premium > 0
          ) {
            let projectDuration = projectDurations[projectName];

            // Check if duration is in seconds and convert to hours

            const hoursWorked =
              projectDuration > 100 ? projectDuration / 3600 : projectDuration;

            const premiumPerHour = parseFloat(matchingProject.premium) || 0;

            const totalPremium = hoursWorked * premiumPerHour;

            console.log(
              `Found project duration in activities: ${projectName}: ${hoursWorked.toFixed(
                2,
              )} hours, premium: ${premiumPerHour} EUR/hour, total: ${totalPremium.toFixed(
                2,
              )} EUR`,
            );

            projectPremiumsByHours.push({
              name: projectName,

              hoursWorked: this.roundToTwoDecimals(hoursWorked),

              premiumPerHour: premiumPerHour,

              totalPremium: this.roundToTwoDecimals(totalPremium),
            });
          }
        });
      }
    }

    console.log(
      "Calculated project premiums by hours:",

      projectPremiumsByHours,
    );

    return projectPremiumsByHours.sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically
  }

  /**
   * Get project premium from query41 data
   * @param {string} projectName - Name of the project
   * @param {Object} query41Data - Premium per project data
   * @returns {number|null} Premium amount or null if not found
   */

  static getProjectPremiumFromQuery41(projectName, query41Data) {
    if (
      !query41Data ||
      !query41Data.project_name ||
      !query41Data.premium ||
      !projectName
    ) {
      return null;
    }

    // Find the project index in the query41 data

    const projectIndex = query41Data.project_name.findIndex(
      (name) => name && name.toLowerCase() === projectName.toLowerCase(),
    );

    if (projectIndex !== -1 && query41Data.premium[projectIndex] !== null) {
      return parseFloat(query41Data.premium[projectIndex]) || 0;
    }

    return null;
  }

  /**
   * Calculate liveshow special premiums based on query50 data
   * @param {Object} apiWorkerData - Raw API worker data
   * @param {Object} query50Data - Special liveshow premiums data
   * @param {Array} allWorkerData - All worker data for global calculations (optional)
   * @param {Object} getDurchGefuehrteLSData - Direct access to getDurchGefuehrteLS data source (optional)
   * @returns {Array} Array of liveshow premium activities
   */

  static calculateLiveshowPremiums(
    apiWorkerData,

    query50Data = null,

    allWorkerData = null,

    getDurchGefuehrteLSData = null,
  ) {
    const liveshowPremiums = [];

    if (
      !query50Data ||
      !query50Data.name ||
      !query50Data.premium ||
      !query50Data.workers_data
    ) {
      console.log("No query50 data available, skipping liveshow premiums");

      return liveshowPremiums;
    }

    console.log("Processing liveshow premiums with query50 data:", query50Data);

    const workerName = apiWorkerData.name;

    const workerId = apiWorkerData.id || apiWorkerData._id;

    console.log("Worker data for liveshow calculations:", {
      name: workerName,

      id: workerId,

      total_billed_out_of_ls: apiWorkerData.total_billed_out_of_ls,

      total_canceled_out_of_ls: apiWorkerData.total_canceled_out_of_ls,

      children: apiWorkerData.children ? apiWorkerData.children.length : 0,
    });

    // Debug: Check all worker data keys that might contain liveshow data

    const liveshowRelatedKeys = Object.keys(apiWorkerData).filter(
      (key) =>
        key.toLowerCase().includes("liveshow") ||
        key.toLowerCase().includes("out_of_ls") ||
        key.toLowerCase().includes("billed") ||
        key.toLowerCase().includes("canceled"),
    );

    console.log("Liveshow-related keys in worker data:", liveshowRelatedKeys);

    liveshowRelatedKeys.forEach((key) => {
      console.log(`${key}:`, apiWorkerData[key]);
    });

    // Process each special premium type

    for (let i = 0; i < query50Data.name.length; i++) {
      const premiumName = query50Data.name[i];

      const premiumAmount = query50Data.premium[i];

      const assignedWorkers = query50Data.workers_data[i] || [];

      console.log(
        `Checking premium ${i}: ${premiumName}, amount: ${premiumAmount}, assigned workers:`,

        assignedWorkers,
      );

      // Check if this worker is assigned to this special premium

      const isWorkerAssigned = assignedWorkers.some(
        (worker) => worker.name === workerName || worker.id === workerId,
      );

      console.log(
        `Worker ${workerName} (${workerId}) assigned to ${premiumName}: ${isWorkerAssigned}`,
      );

      if (!isWorkerAssigned) {
        console.log(
          `Worker ${workerName} not assigned to premium ${premiumName}`,
        );

        continue;
      }

      console.log(
        `Processing ${premiumName} for ${workerName}, premium: ${premiumAmount} EUR`,
      );

      let count = 0;

      let billedCount = 0;

      let canceledCount = 0;

      let totalPremium = 0;

      switch (premiumName) {
        case "Liveshow durchgeführt":
          // Calculate net liveshows: planned/billed - canceled

          // Check if we have specific liveshow billed/canceled data

          let plannedLiveshows = 0;

          let canceledLiveshows = 0;

          // Option 1: Check if there are specific billed/canceled liveshow fields

          if (
            apiWorkerData.total_billed_live_shows !== undefined &&
            apiWorkerData.total_canceled_live_shows !== undefined
          ) {
            plannedLiveshows = apiWorkerData.total_billed_live_shows || 0;

            canceledLiveshows = apiWorkerData.total_canceled_live_shows || 0;

            console.log(
              `Using specific liveshow billed/canceled data: ${plannedLiveshows} planned - ${canceledLiveshows} canceled`,
            );
          }

          // Option 2: Use live_shows array if available
          else if (
            apiWorkerData.live_shows &&
            Array.isArray(apiWorkerData.live_shows)
          ) {
            // Sum up recordCount from live_shows array

            plannedLiveshows = apiWorkerData.live_shows.reduce(
              (sum, ls) => sum + (parseInt(ls.recordCount) || 0),

              0,
            );

            // Assume no cancellations unless we find canceled data

            canceledLiveshows = 0;

            console.log(
              `Using live_shows array: ${plannedLiveshows} total liveshows from ${apiWorkerData.live_shows.length} records`,
            );
          }

          // Option 3: Use total_live_shows as completed count (assume all planned were completed)
          else if (apiWorkerData.total_live_shows !== undefined) {
            plannedLiveshows = apiWorkerData.total_live_shows || 0;

            canceledLiveshows = 0; // No cancellation data available

            console.log(
              `Using total_live_shows: ${plannedLiveshows} completed liveshows (assuming no cancellations)`,
            );
          }

          // Option 4: Fallback to counting liveshow projects
          else if (
            apiWorkerData.children &&
            Array.isArray(apiWorkerData.children)
          ) {
            const liveshowProjects = apiWorkerData.children.filter(
              (project) =>
                project.name && project.name.toLowerCase().includes("liveshow"),
            );

            plannedLiveshows = liveshowProjects.length;

            canceledLiveshows = 0; // No cancellation data from projects

            console.log(
              `Using liveshow projects: ${plannedLiveshows} projects found`,
            );
          }

          // Apply the standard formula: (vereinbart - abgesagt) × prämie

          count = Math.max(0, plannedLiveshows - canceledLiveshows); // Net performed liveshows

          billedCount = plannedLiveshows; // Show planned/agreed liveshows in "Vereinbart" column

          canceledCount = canceledLiveshows; // Show canceled liveshows in "Abgesagt" column

          totalPremium = count * premiumAmount; // Premium based on net count

          console.log(
            `Liveshow durchgeführt for ${workerName}: ${plannedLiveshows} planned - ${canceledLiveshows} canceled = ${count} net, Premium: ${totalPremium.toFixed(
              2,
            )} EUR`,
          );

          break;

        case "Liveshow stattgefunden":
          // Calculate global total: this represents liveshows that actually took place

          // Following the (vereinbart - abgesagt) formula globally

          try {
            // Access the raw getDurchGefuehrteLS data - try parameter first, then global variable

            const rawLiveshowData =
              getDurchGefuehrteLSData ||
              (typeof getDurchGefuehrteLS !== "undefined"
                ? getDurchGefuehrteLS?.data
                : null);

            let globalPerformed = 0;

            let globalPlanned = 0;

            let globalCanceled = 0;

            if (rawLiveshowData && Array.isArray(rawLiveshowData)) {
              // Sum all recordCount values from the raw data (these are performed liveshows)

              globalPerformed = rawLiveshowData.reduce((total, record) => {
                return total + (parseInt(record.recordCount) || 0);
              }, 0);

              // For "Liveshow stattgefunden", the getDurchGefuehrteLS data represents liveshows that actually happened

              // This is already the net result of (planned - canceled)

              // So we treat performed liveshows as the final count for premium calculation

              globalPlanned = globalPerformed; // We don't have separate planned data, so use performed as basis

              globalCanceled = 0; // Assume no additional cancellations since these already happened

              console.log(
                `✅ Global liveshow calculation from getDurchGefuehrteLS: ${globalPerformed} performed liveshows across all workers, assigned to ${workerName}`,
              );

              console.log(
                `getDurchGefuehrteLS data sample:`,

                rawLiveshowData.slice(0, 3),
              );
            } else if (allWorkerData && Array.isArray(allWorkerData)) {
              // Fallback: Calculate global total across all workers

              globalPerformed = allWorkerData.reduce((total, worker) => {
                return total + (worker.total_live_shows || 0);
              }, 0);

              globalPlanned = globalPerformed;

              globalCanceled = 0;

              console.log(
                `⚠️ Fallback global calculation from allWorkerData: ${globalPerformed} total liveshows across ${allWorkerData.length} workers, assigned to ${workerName}`,
              );
            } else {
              // Last resort: Use individual worker data (not really global)

              globalPerformed = apiWorkerData.total_live_shows || 0;

              globalPlanned = globalPerformed;

              globalCanceled = 0;

              console.log(
                `❌ Last resort: Using individual worker data for ${workerName}: ${globalPerformed} liveshows`,
              );
            }

            // Apply the standard formula: (vereinbart - abgesagt) × prämie

            count = Math.max(0, globalPlanned - globalCanceled); // Net performed liveshows

            billedCount = globalPlanned; // Show planned liveshows in "Vereinbart" column

            canceledCount = globalCanceled; // Show canceled liveshows in "Abgesagt" column

            totalPremium = count * premiumAmount; // Premium based on net count

            console.log(
              `Liveshow stattgefunden global calculation: ${globalPlanned} planned - ${globalCanceled} canceled = ${count} net, Premium: ${totalPremium.toFixed(
                2,
              )} EUR (assigned to ${workerName})`,
            );
          } catch (error) {
            console.error(`Error calculating global liveshow total:`, error);

            // Fallback to individual worker data

            count = apiWorkerData.total_live_shows || 0;

            billedCount = count;

            canceledCount = 0;

            totalPremium = count * premiumAmount;

            console.log(
              `❌ Error fallback: Using individual worker data for ${workerName}: ${count} liveshows`,
            );
          }

          break;

        case "Folgetermine aus Liveshows":
          // Net activities from liveshows (billed - canceled)

          const billedFromLS = apiWorkerData.total_billed_out_of_ls || 0;

          const canceledFromLS = apiWorkerData.total_canceled_out_of_ls || 0;

          // Debug: Show all liveshow-related fields for this worker

          console.log(`=== FOLGETERMINE DEBUG for ${workerName} ===`);

          console.log(
            `total_billed_out_of_ls: ${apiWorkerData.total_billed_out_of_ls}`,
          );

          console.log(
            `total_canceled_out_of_ls: ${apiWorkerData.total_canceled_out_of_ls}`,
          );

          console.log(
            `billed_activities_out_of_ls:`,

            apiWorkerData.billed_activities_out_of_ls,
          );

          console.log(
            `canceled_activities_out_of_ls:`,

            apiWorkerData.canceled_activities_out_of_ls,
          );

          // Check if we have detailed activity arrays to calculate manually

          let manualBilledCount = 0;

          let manualCanceledCount = 0;

          if (
            apiWorkerData.billed_activities_out_of_ls &&
            Array.isArray(apiWorkerData.billed_activities_out_of_ls)
          ) {
            manualBilledCount =
              apiWorkerData.billed_activities_out_of_ls.reduce(
                (sum, activity) => sum + (activity.recordCount || 0),

                0,
              );

            console.log(
              `Manual billed count from activity array: ${manualBilledCount}`,
            );
          }

          if (
            apiWorkerData.canceled_activities_out_of_ls &&
            Array.isArray(apiWorkerData.canceled_activities_out_of_ls)
          ) {
            manualCanceledCount =
              apiWorkerData.canceled_activities_out_of_ls.reduce(
                (sum, activity) => sum + (activity.recordCount || 0),

                0,
              );

            console.log(
              `Manual canceled count from activity array: ${manualCanceledCount}`,
            );
          }

          // Use manual counts if available and aggregated totals are 0

          const finalBilledCount =
            billedFromLS > 0 ? billedFromLS : manualBilledCount;

          const finalCanceledCount =
            canceledFromLS > 0 ? canceledFromLS : manualCanceledCount;

          count = Math.max(0, finalBilledCount - finalCanceledCount);

          billedCount = finalBilledCount;

          canceledCount = finalCanceledCount;

          totalPremium = count * premiumAmount;

          console.log(
            `Folgetermine calculation for ${workerName}: ${finalBilledCount} billed - ${finalCanceledCount} canceled = ${count} net, premium: ${totalPremium}`,
          );

          console.log(`=== END FOLGETERMINE DEBUG ===`);

          break;

        default:
          console.log(`Unknown premium type: ${premiumName}`);

          continue;
      }

      // Add premium to list if assigned to this worker (even if count is 0)

      if (totalPremium > 0 || count > 0 || billedCount > 0) {
        liveshowPremiums.push({
          name: premiumName,

          appointments: billedCount, // Show "vereinbart" (gross/billed) in appointments column

          cancellations: canceledCount, // Show "abgesagt" (canceled) in cancellations column

          premiumPerAppointment: premiumAmount, // Add this property for PDF rendering

          premium: this.roundToTwoDecimals(totalPremium), // Premium calculated from net count (billedCount - canceledCount)
        });

        console.log(
          `✅ Added ${premiumName}: ${billedCount} vereinbart - ${canceledCount} abgesagt = ${count} net, Premium: ${totalPremium.toFixed(
            2,
          )} EUR`,
        );
      } else {
        console.log(
          `❌ No premium added for ${premiumName}: billedCount=${billedCount}, canceledCount=${canceledCount}, net=${count}, totalPremium=${totalPremium}`,
        );
      }
    }

    console.log(
      `Total liveshow premiums calculated: ${liveshowPremiums.length}`,

      liveshowPremiums,
    );

    return liveshowPremiums;
  }

  /**
   * Check if worker is assigned to any liveshow premium groups in query50 data
   * @param {Object} apiWorkerData - Raw API worker data
   * @param {Object} query50Data - Liveshow premium data from query50
   * @returns {boolean} True if worker is in any liveshow group
   */

  static isWorkerInLiveshowGroups(apiWorkerData, query50Data) {
    if (
      !query50Data ||
      !query50Data.workers_data ||
      !Array.isArray(query50Data.workers_data)
    ) {
      console.log(
        "No query50 data available to check liveshow group membership",
      );

      return false;
    }

    const workerId = apiWorkerData.id || apiWorkerData._id;

    const workerName = apiWorkerData.name;

    // Check each liveshow premium group

    for (let i = 0; i < query50Data.workers_data.length; i++) {
      const groupWorkers = query50Data.workers_data[i];

      if (Array.isArray(groupWorkers)) {
        const isInGroup = groupWorkers.some(
          (worker) => worker.id === workerId || worker.name === workerName,
        );

        if (isInGroup) {
          console.log(
            `Worker ${workerName} found in liveshow group ${i} (${query50Data.name[i]})`,
          );

          return true;
        }
      }
    }

    console.log(`Worker ${workerName} not found in any liveshow groups`);

    return false;
  }

  /**
   * Utility method to round numbers to 2 decimal places
   * @param {number} num - Number to round
   * @returns {number} Rounded number
   */

  static roundToTwoDecimals(num) {
    return Math.round((num + Number.EPSILON) * 100) / 100;
  }

  /**
   * Utility method to safely convert percentage values
   * @param {number} value - Value to convert to percentage
   * @returns {number} Percentage value
   */

  static toPercentage(value) {
    return value ? this.roundToTwoDecimals(value * 100) : 0;
  }

  /**
   * Smart formatting for premium amounts based on the base rate
   * If base rate (premiumPerAppointment) is whole number, result is rounded to whole number
   * If base rate has decimals, result keeps 2 decimal places
   * @param {number} amount - The calculated premium amount
   * @param {number} baseRate - The base rate (premium per appointment/hour)
   * @returns {string} Formatted amount
   */

  static formatPremiumAmount(amount, baseRate) {
    if (!amount && amount !== 0) return "0";

    if (!baseRate && baseRate !== 0)
      return this.roundToTwoDecimals(amount).toString();

    // Check if base rate is a whole number

    const isWholeNumber = baseRate === Math.floor(baseRate);

    if (isWholeNumber) {
      // Round to whole number if base rate is whole

      return Math.round(amount).toString();
    } else {
      // Keep 2 decimals if base rate has decimals

      return this.roundToTwoDecimals(amount).toFixed(2);
    }
  }
}

// Export for different environments

if (typeof module !== "undefined" && module.exports) {
  module.exports = KRAUSSPDFGenerator;
} else if (typeof window !== "undefined") {
  window.KRAUSSPDFGenerator = KRAUSSPDFGenerator;
}

// ===== RETOOL INTEGRATION HANDLERS =====

/**
 * Safely get formatted date for filenames
 * @param {string} format - Date format (default: "YYYY-MM")
 * @returns {string} Formatted date
 */

function getSafeDate(format = "YYYY-MM") {
  if (dateRangeSelector?.value?.start) {
    return dateRangeSelector.value.start.format(format);
  } else if (typeof moment !== "undefined") {
    return moment().format(format);
  } else {
    const now = new Date();

    if (format === "YYYY-MM") {
      return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(
        2,

        "0",
      )}`;
    }

    return now.toISOString().slice(0, 7); // YYYY-MM format
  }
}

/**
 * Show improved notification with better UX
 * @param {string} title - Notification title
 * @param {string} description - Notification description
 * @param {string} type - Notification type: "info" | "success" | "warning" | "error"
 * @param {number} duration - Duration in seconds (default 4.5)
 * @param {boolean} waitForDisplay - Whether to wait for notification to display (default true)
 */

async function showNotification(
  title,

  description = "",

  type = "info",

  duration = 4.5,

  waitForDisplay = true,
) {
  try {
    if (typeof utils !== "undefined" && utils.showNotification) {
      utils.showNotification({
        title: title,

        description: description,

        notificationType: type,

        duration: duration,
      });

      // Small delay to ensure notification is displayed before continuing

      if (waitForDisplay) {
        await new Promise((resolve) => setTimeout(resolve, 150));
      }
    } else {
      // Fallback to console for debugging

      console.log(
        `[${type.toUpperCase()}] ${title}${
          description ? ": " + description : ""
        }`,
      );
    }
  } catch (error) {
    console.error("Failed to show notification:", error);

    console.log(
      `[${type.toUpperCase()}] ${title}${description ? ": " + description : ""}`,
    );
  }
}

/**
 * Download a blob as a file
 * @param {Blob} blob - The blob to download
 * @param {string} filename - The filename for the download
 */

function downloadBlob(blob, filename) {
  try {
    // Try to get URL object (works in browser and most environments)

    const URLObject = window.URL || window.webkitURL || URL;

    if (!URLObject || typeof URLObject.createObjectURL !== "function") {
      throw new Error(
        "URL.createObjectURL is not available in this environment",
      );
    }

    const url = URLObject.createObjectURL(blob);

    const a = document.createElement("a");

    a.style.display = "none";

    a.href = url;

    a.download = filename;

    document.body.appendChild(a);

    a.click();

    // Clean up

    setTimeout(() => {
      URLObject.revokeObjectURL(url);

      document.body.removeChild(a);
    }, 100);
  } catch (error) {
    console.error("Error in downloadBlob:", error);

    // Fallback: Try using Retool's download utilities if available

    if (typeof utils !== "undefined" && utils.downloadFile) {
      console.log("Using Retool utils.downloadFile as fallback");

      utils.downloadFile(blob, filename);
    } else if (typeof parent !== "undefined" && parent.postMessage) {
      // Try to communicate with parent frame (Retool container)

      console.log("Attempting to use parent frame messaging");

      parent.postMessage(
        {
          type: "DOWNLOAD_FILE",

          blob: blob,

          filename: filename,
        },

        "*",
      );
    } else {
      throw new Error("Unable to download file: No download method available");
    }
  }
}

/**
 * Load JSZip library dynamically
 * @returns {Promise} Promise that resolves when JSZip is loaded
 */

async function loadJSZip() {
  return new Promise(async (resolve, reject) => {
    if (typeof JSZip !== "undefined") {
      resolve();

      return;
    }

    // Show loading notification and wait for display

    await showNotification(
      "ZIP-Bibliothek wird geladen... ⏳",

      "JSZip wird heruntergeladen",

      "info",

      3,
    );

    const script = document.createElement("script");

    script.src =
      "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";

    script.onload = async () => {
      console.log("JSZip library loaded successfully");

      await showNotification(
        "ZIP-Bibliothek geladen ✅",

        "Batch-Verarbeitung kann fortgesetzt werden",

        "success",

        2,
      );

      resolve();
    };

    script.onerror = async () => {
      await showNotification(
        "ZIP-Bibliothek Fehler ❌",

        "JSZip konnte nicht geladen werden. Versuchen Sie einzelne Downloads.",

        "error",

        6,

        false,
      );

      reject(new Error("Failed to load JSZip library"));
    };

    document.head.appendChild(script);
  });
}

/**
 * Parse query45 data for premium per activity type
 * @param {Object|string} query45Data - Raw query45 data (could be JSON string or object)
 * @returns {Object|null} Parsed query45 data or null if invalid
 */

function parseQuery45Data(query45Data) {
  try {
    let parsedData;

    // If it's a string, try to parse it as JSON

    if (typeof query45Data === "string") {
      parsedData = JSON.parse(query45Data);
    } else if (typeof query45Data === "object" && query45Data !== null) {
      parsedData = query45Data;
    } else {
      return null;
    }

    // Validate that required fields exist

    if (
      !parsedData.name ||
      !parsedData.premium ||
      !Array.isArray(parsedData.name) ||
      !Array.isArray(parsedData.premium)
    ) {
      console.warn("Invalid query45 data structure");

      return null;
    }

    return parsedData;
  } catch (error) {
    console.error("Error parsing query45 data:", error);

    return null;
  }
}

/**
 * Get query45 activity type premium data - tries multiple sources
 * @returns {Object|null} Query45 data or null if not available
 */

function getQuery45Data() {
  return parseQuery45Data(query45.data);
}

/**
 * Parse query47 data for premium per project by hours
 * @param {Object|string} query47Data - Raw query47 data (could be JSON string or object)
 * @returns {Array|null} Parsed query47 data or null if invalid
 */

function parseQuery47Data(query47Data) {
  try {
    let parsedData;

    // If it's a string, try to parse it as JSON

    if (typeof query47Data === "string") {
      parsedData = JSON.parse(query47Data);
    } else if (typeof query47Data === "object" && query47Data !== null) {
      parsedData = query47Data;
    } else {
      return null;
    }

    // If it's not an array, return null

    if (!Array.isArray(parsedData)) {
      console.warn("Invalid query47 data structure - expected array");

      return null;
    }

    return parsedData;
  } catch (error) {
    console.error("Error parsing query47 data:", error);

    return null;
  }
}

/**
 * Get query47 project premium data - tries multiple sources
 * @returns {Array|null} Query47 data or null if not available
 */

function getQuery47Data() {
  return parseQuery47Data(query47.data);
}

/**
 * Get query50 liveshow premium data - tries multiple sources
 * @returns {Object|null} Query50 data or null if not available
 */

function getQuery50Data() {
  return parseQuery50Data(query50.data);
}

/**
 * Parse query50 liveshow premium data from Retool
 * @param {string|Object} data - Raw data from Retool query50
 * @returns {Object|null} Parsed data or null if invalid
 */

function parseQuery50Data(data) {
  try {
    if (!data) return null;

    // If data is a string, parse it as JSON

    const parsedData = typeof data === "string" ? JSON.parse(data) : data;

    console.log("Parsed query50 data:", parsedData);

    // Validate required fields

    if (!parsedData.name || !parsedData.premium || !parsedData.workers_data) {
      console.log("Query50 data missing required fields");

      return null;
    }

    return parsedData;
  } catch (error) {
    console.error("Error parsing query50 data:", error);

    return null;
  }
}

/**
 * Get activity type premium from query45 data
 * @param {string} activityType - Name of the activity type
 * @param {Object} query45Data - Premium per activity type data
 * @returns {number|null} Premium amount or null if not found
 */

function getActivityTypePremiumFromQuery45(activityType, query45Data) {
  if (
    !query45Data ||
    !query45Data.name ||
    !query45Data.premium ||
    !activityType
  ) {
    console.log("Query45 data is missing or incomplete:", query45Data);

    return null;
  }

  console.log(`Searching for activity type: "${activityType}"`);

  console.log("Available names in query45:", query45Data.name);

  // Find the activity type index in the query45 data

  const activityIndex = query45Data.name.findIndex(
    (name) => name && name.toLowerCase() === activityType.toLowerCase(),
  );

  console.log(`Activity index found for "${activityType}":`, activityIndex);

  if (activityIndex !== -1 && query45Data.premium[activityIndex] !== null) {
    const premium = parseFloat(query45Data.premium[activityIndex]) || 0;

    console.log(`Premium for "${activityType}":`, premium);

    return premium;
  }

  console.log(`No premium found for activity type: "${activityType}"`);

  return null;
}

function parseQuery41Data(query41Data) {
  try {
    let parsedData;

    // If it's a string, try to parse it as JSON

    if (typeof query41Data === "string") {
      parsedData = JSON.parse(query41Data);
    } else if (typeof query41Data === "object" && query41Data !== null) {
      parsedData = query41Data;
    } else {
      return null;
    }

    // Validate that required fields exist

    if (
      !parsedData.project_name ||
      !parsedData.premium ||
      !Array.isArray(parsedData.project_name) ||
      !Array.isArray(parsedData.premium)
    ) {
      console.warn("Invalid query41 data structure");

      return null;
    }

    return parsedData;
  } catch (error) {
    console.error("Error parsing query41 data:", error);

    return null;
  }
}

/**
 * Get query41 premium data - tries multiple sources
 * @returns {Object|null} Query41 data or null if not available
 */

function getQuery41Data() {
  return parseQuery41Data(query41.data);
}

/**
 * Parse query53 absence code data
 * @param {Array|string} query53Data - Raw query53 data (could be JSON string or array)
 * @returns {Array|null} Parsed query53 data or null if invalid
 */

function parseQuery53Data(query53Data) {
  try {
    if (!query53Data) {
      console.log("No query53 data provided");

      return null;
    }

    let data = query53Data;

    if (typeof query53Data === "string") {
      data = JSON.parse(query53Data);
    }

    if (Array.isArray(data) && data.length > 0) {
      console.log("Query53 parsed successfully:", data.length, "absence codes");

      return data;
    }

    return null;
  } catch (error) {
    console.error("Error parsing query53 data:", error);

    return null;
  }
}

/**
 * Get query53 absence code mapping data
 * @returns {Array|null} Query53 data or null if not available
 */

function getQuery53Data() {
  if (typeof query53 !== "undefined" && query53?.data) {
    return parseQuery53Data(query53.data);
  }

  console.log("query53 not available");

  return null;
}

/**
 * Create a code-to-type mapping from query53 data
 * @param {Array} query53Data - Query53 absence code data
 * @returns {Object} Map of code -> type
 */

function createAbsenceCodeTypeMap(query53Data) {
  if (!query53Data || !Array.isArray(query53Data)) {
    return {};
  }

  const map = {};

  query53Data.forEach((item) => {
    if (item.code && item.type) {
      map[item.code] = item.type;
    }
  });

  console.log("Absence code to type map:", map);

  return map;
}

/**
 * Debug all liveshow data sources
 */

function debugLiveshowDataSources() {
  console.log("=== LIVESHOW DATA SOURCES DEBUG ===");

  // Check getActivitesOutOfLS

  if (typeof getActivitesOutOfLS !== "undefined" && getActivitesOutOfLS?.data) {
    console.log(
      `getActivitesOutOfLS: ${getActivitesOutOfLS.data.length} records`,
    );

    console.log(
      "Sample getActivitesOutOfLS:",

      getActivitesOutOfLS.data.slice(0, 2),
    );
  } else {
    console.warn("getActivitesOutOfLS data not available");
  }

  // Check getCanelledActivitesOutOfLS

  if (
    typeof getCanelledActivitesOutOfLS !== "undefined" &&
    getCanelledActivitesOutOfLS?.data
  ) {
    console.log(
      `getCanelledActivitesOutOfLS: ${getCanelledActivitesOutOfLS.data.length} records`,
    );

    console.log(
      "Sample getCanelledActivitesOutOfLS:",

      getCanelledActivitesOutOfLS.data.slice(0, 2),
    );

    // Look for Vanessa specifically

    const vanessaCanceled = getCanelledActivitesOutOfLS.data.filter(
      (record) =>
        record.Vereinbart_von__c &&
        record.Vereinbart_von__c.includes("Vanessa"),
    );

    console.log(
      `Vanessa's canceled out-of-LS activities: ${vanessaCanceled.length} records`,

      vanessaCanceled,
    );
  } else {
    console.warn("getCanelledActivitesOutOfLS data not available");
  }

  // Check getDurchGefuehrteLS

  if (typeof getDurchGefuehrteLS !== "undefined" && getDurchGefuehrteLS?.data) {
    console.log(
      `getDurchGefuehrteLS: ${getDurchGefuehrteLS.data.length} records`,
    );

    console.log(
      "Sample getDurchGefuehrteLS:",

      getDurchGefuehrteLS.data.slice(0, 2),
    );
  } else {
    console.warn("getDurchGefuehrteLS data not available");
  }

  console.log("=== END LIVESHOW DATA SOURCES DEBUG ===");
}

/**
 * Debug worker liveshow data to identify missing fields
 * @param {Object} workerData - Worker data to debug
 */

function debugWorkerLiveshowData(workerData) {
  console.groupCollapsed(`🎬 Liveshow Data: ${workerData.name}`);

  const liveshowData = {
    total_billed_out_of_ls: workerData.total_billed_out_of_ls ?? 0,

    total_canceled_out_of_ls: workerData.total_canceled_out_of_ls ?? 0,

    total_live_shows: workerData.total_live_shows ?? 0,

    billed_activities_out_of_ls:
      workerData.billed_activities_out_of_ls ?? "N/A",

    canceled_activities_out_of_ls:
      workerData.canceled_activities_out_of_ls ?? "N/A",

    live_shows: workerData.live_shows ?? "N/A",
  };

  console.table([liveshowData]);

  console.groupEnd();
}

/**
 * Get getDurchGefuehrteLS data for debugging
 * @returns {Array} Raw getDurchGefuehrteLS data
 */

function getGetDurchGefuehrteLSData() {
  if (typeof getDurchGefuehrteLS !== "undefined" && getDurchGefuehrteLS?.data) {
    console.log(
      "getDurchGefuehrteLS data found:",

      getDurchGefuehrteLS.data.length,

      "records",
    );

    const total = getDurchGefuehrteLS.data.reduce(
      (sum, record) => sum + (parseInt(record.recordCount) || 0),

      0,
    );

    console.log("Total liveshow count from getDurchGefuehrteLS:", total);

    return getDurchGefuehrteLS.data;
  } else {
    console.warn("getDurchGefuehrteLS data not available");

    return [];
  }
}

/**
 * Get query43 worker data with liveshow fields
 * @returns {Array} Array of worker data from query43
 */

function getQuery43Data() {
  if (!query43?.data) {
    console.warn(
      "Query43 data not available - make sure query43 is set up and running",
    );

    return [];
  }

  return query43.data;
}

/**
 * MAIN RETOOL HANDLER - Generate PDF for selected worker
 * Use this as the onClick handler for your Retool button
 * Requires: workerHoursOverview table with selectedRow data
 */

async function generateWorkerAgreementPDF() {
  try {
    console.log("Starting PDF generation...");

    const generator = new KRAUSSPDFGenerator();

    // Get selected worker data from Retool table

    const selectedWorker = workerHoursOverview?.selectedRow;

    if (!selectedWorker) {
      throw new Error("Please select a worker from the table first");
    }

    console.log("=== SINGLE EXPORT SELECTED WORKER ===");

    console.log("Selected worker data:", selectedWorker);

    console.log(
      "Selected worker probezeitende:",

      selectedWorker.probezeitende,

      "(type:",

      typeof selectedWorker.probezeitende,

      ")",
    );

    console.log(
      "Selected worker end_date:",

      selectedWorker.end_date,

      "(type:",

      typeof selectedWorker.end_date,

      ")",
    );

    console.log("All date-related fields:", {
      probezeitende: selectedWorker.probezeitende,

      end_date: selectedWorker.end_date,

      start_date: selectedWorker.start_date,
    });

    // Merge with query43 data to get liveshow-specific fields

    const query43Data = getQuery43Data();

    console.log("=== QUERY43 DEBUG ===");

    console.log("Query43 data length:", query43Data.length);

    console.log(
      "Selected worker ID:",

      selectedWorker._id,

      "Name:",

      selectedWorker.name,
    );

    // Show first few workers from query43 to check structure

    if (query43Data.length > 0) {
      console.log(
        "First query43 worker structure:",

        Object.keys(query43Data[0]),
      );

      console.log(
        "Query43 worker names:",

        query43Data.map((w) => w.name).slice(0, 5),
      );

      // Look for Vanessa specifically

      const vanessaWorker = query43Data.find(
        (w) => w.name && w.name.includes("Vanessa"),
      );

      if (vanessaWorker) {
        console.log("Found Vanessa in query43:", {
          name: vanessaWorker.name,

          _id: vanessaWorker._id,

          id: vanessaWorker.id,

          total_billed_out_of_ls: vanessaWorker.total_billed_out_of_ls,

          total_canceled_out_of_ls: vanessaWorker.total_canceled_out_of_ls,

          total_live_shows: vanessaWorker.total_live_shows,
        });
      }
    }

    const matchingQuery43Worker = query43Data.find(
      (worker) =>
        worker._id === selectedWorker._id ||
        worker.id === selectedWorker.id ||
        worker.name === selectedWorker.name,
    );

    console.log("Matching query43 worker found:", !!matchingQuery43Worker);

    if (matchingQuery43Worker) {
      console.log("Matching worker liveshow data:", {
        name: matchingQuery43Worker.name,

        total_billed_out_of_ls: matchingQuery43Worker.total_billed_out_of_ls,

        total_canceled_out_of_ls:
          matchingQuery43Worker.total_canceled_out_of_ls,

        total_live_shows: matchingQuery43Worker.total_live_shows,
      });

      console.log(
        "Query43 worker probezeitende:",

        matchingQuery43Worker.probezeitende,
      );

      console.log("Query43 worker end_date:", matchingQuery43Worker.end_date);
    }

    // Merge selectedWorker with matching query43 worker to include liveshow fields

    // Only merge non-null values from query43 to preserve probezeitende from selectedWorker

    let enrichedWorker = { ...selectedWorker };

    if (matchingQuery43Worker) {
      Object.keys(matchingQuery43Worker).forEach((key) => {
        // Only overwrite if query43 value is not null/undefined OR if selectedWorker doesn't have it

        if (matchingQuery43Worker[key] != null || selectedWorker[key] == null) {
          enrichedWorker[key] = matchingQuery43Worker[key];
        }
      });
    }

    console.log("=== ENRICHMENT RESULT ===");

    console.log("Enriched worker data with liveshow fields:", {
      name: enrichedWorker.name,

      total_billed_out_of_ls: enrichedWorker.total_billed_out_of_ls,

      total_canceled_out_of_ls: enrichedWorker.total_canceled_out_of_ls,

      total_live_shows: enrichedWorker.total_live_shows,

      hasLiveshowFields: !!matchingQuery43Worker,
    });

    // Debug the enriched worker's liveshow data in detail

    debugWorkerLiveshowData(enrichedWorker);

    // Get query41 premium data

    const query41Data = getQuery41Data();

    console.log("Query41 premium data:", query41Data);

    // Get query45 activity type premium data

    const query45Data = getQuery45Data();

    console.log("Query45 activity type premium data:", query45Data);

    // Get query47 project premium data

    const query47Data = getQuery47Data();

    console.log("Query47 project premium data:", query47Data);

    // Get query50 liveshow premium data

    const query50Data = getQuery50Data();

    console.log("Query50 liveshow premium data:", query50Data);

    // Get query53 absence code mapping data

    const query53Data = getQuery53Data();

    console.log("Query53 absence code data:", query53Data);

    // Debug getDurchGefuehrteLS data for global liveshow calculation

    const getDurchGefuehrteLSData = getGetDurchGefuehrteLSData();

    // Debug all liveshow data sources

    debugLiveshowDataSources();

    // Transform API data to document format with premium data

    const documentData = KRAUSSPDFGenerator.transformAPIData(
      enrichedWorker,

      query41Data,

      query45Data,

      query47Data,

      query50Data,

      null, // No global data available for single worker generation

      getDurchGefuehrteLSData,

      query53Data, // Pass absence code mapping
    );

    console.log("Transformed data:", documentData);

    // Generate filename

    const filename = `${documentData.employee.name.replace(
      /\s+/g,

      "_",
    )}_Zielvereinbarung_${getSafeDate("YYYY-MM")}.pdf`;

    // Generate and download PDF

    await generator.generateDocument(documentData, {
      download: true,

      filename: filename,
    });

    // Show success notification

    await showNotification(
      "PDF erfolgreich generiert! 📄",

      `Zielvereinbarung für ${documentData.employee.name} wurde heruntergeladen`,

      "success",

      5,

      false, // Don't wait since this is the final notification
    );

    return {
      success: true,

      filename: filename,

      employee: documentData.employee.name,
    };
  } catch (error) {
    console.error("PDF Generation Error:", error);

    await showNotification(
      "PDF-Generierung fehlgeschlagen ❌",

      error.message,

      "error",

      6,

      false,
    );

    return { success: false, error: error.message };
  }
}

/**
 * BATCH PROCESSING HANDLER - Generate PDFs for multiple workers as ZIP download
 * Use this for batch processing from query data
 * Requires: query43 with worker data array
 */

async function generateBatchWorkerAgreements() {
  try {
    console.log("Starting batch ZIP generation...");

    // Load JSZip library dynamically if not available

    if (typeof JSZip === "undefined") {
      await loadJSZip();
    }

    const generator = new KRAUSSPDFGenerator();

    const zip = new JSZip();

    // Get worker data from query

    const workerData = query43?.data;

    if (!workerData || !Array.isArray(workerData) || workerData.length === 0) {
      await showNotification(
        "Keine Daten verfügbar ⚠️",

        "Es wurden keine Mitarbeiterdaten für die Batch-Verarbeitung gefunden",

        "warning",

        5,

        false,
      );

      throw new Error("No worker data available for batch processing");
    }

    // Show start notification and wait for it to display

    await showNotification(
      "ZIP-Erstellung gestartet... ⏳",

      `${workerData.length} Zielvereinbarungen werden verarbeitet`,

      "info",

      3,
    );

    console.time("⏱️ Batch ZIP Processing");

    console.info(
      `🚀 Starting batch processing for ${workerData.length} workers`,
    );

    // Debug: Check what fields are available in query43 data

    if (workerData.length > 0) {
      console.groupCollapsed("📊 Query43 Data Structure");

      const firstWorker = workerData[0];

      console.log("Available fields:", Object.keys(firstWorker).length);

      console.table([
        {
          probezeitende: firstWorker.probezeitende ?? "undefined",

          end_date: firstWorker.end_date ?? "null",

          start_date: firstWorker.start_date,
        },
      ]);

      console.assert(
        firstWorker.probezeitende ||
          firstWorker.end_date ||
          firstWorker.start_date,

        "⚠️ WARNING: No date fields available! Probation period will be calculated from start_date",
      );

      console.groupEnd();
    }

    // Get query41 premium data once for all workers

    const query41Data = getQuery41Data();

    console.log(
      "Using query41 premium data for batch processing:",

      query41Data,
    );

    // Get query45 activity type premium data once for all workers

    const query45Data = getQuery45Data();

    console.log(
      "Using query45 activity type premium data for batch processing:",

      query45Data,
    );

    // Get query47 project premium data once for all workers

    const query47Data = getQuery47Data();

    console.log(
      "Using query47 project premium data for batch processing:",

      query47Data,
    );

    // Get query50 liveshow premium data once for all workers

    const query50Data = getQuery50Data();

    console.log(
      "Using query50 liveshow premium data for batch processing:",

      query50Data,
    );

    // Get query53 absence code mapping data once for all workers

    const query53Data = getQuery53Data();

    console.log(
      "Using query53 absence code data for batch processing:",

      query53Data,
    );

    let successCount = 0;

    let errorCount = 0;

    const results = {
      successful: [],

      failed: [],
    };

    // Process each worker and collect PDFs for ZIP

    const pdfPromises = workerData.map(async (worker, index) => {
      try {
        // Show individual progress notification

        await showNotification(
          `Erstelle PDF ${index + 1}/${workerData.length} 📄`,

          `Bearbeite Zielvereinbarung für ${worker.name || "Mitarbeiter"}`,

          "info",

          2,

          true,
        );

        console.log(
          `Processing ${index + 1}/${workerData.length}: ${
            worker.name || "Unknown"
          }`,
        );

        // Ensure worker data is complete - merge with workerHoursOverview if needed

        // This ensures batch has same data structure as single export

        let enrichedWorker = worker;

        // Check if we have workerHoursOverview data and merge if available

        if (
          typeof workerHoursOverview !== "undefined" &&
          workerHoursOverview?.data
        ) {
          const matchingOverviewWorker = workerHoursOverview.data.find(
            (w) =>
              w._id === worker._id ||
              w.id === worker.id ||
              w.name === worker.name,
          );

          if (matchingOverviewWorker) {
            if (index === 0) {
              console.groupCollapsed(`🔄 Data Merge: ${worker.name}`);

              console.table([
                {
                  source: "query43",

                  probezeitende: worker.probezeitende ?? "undefined",

                  end_date: worker.end_date ?? "null",

                  start_date: worker.start_date,
                },

                {
                  source: "overview",

                  probezeitende:
                    matchingOverviewWorker.probezeitende ?? "undefined",

                  end_date: matchingOverviewWorker.end_date ?? "null",

                  start_date: matchingOverviewWorker.start_date,
                },
              ]);
            }

            // Smart merge: start with query43, then override with non-null values from overview

            // This preserves probezeitende and other overview-specific fields

            enrichedWorker = { ...worker };

            Object.keys(matchingOverviewWorker).forEach((key) => {
              // Only overwrite if overview value is not null/undefined OR if worker doesn't have it

              if (matchingOverviewWorker[key] != null || worker[key] == null) {
                enrichedWorker[key] = matchingOverviewWorker[key];
              }
            });

            if (index === 0) {
              console.log("✅ Merged:", {
                probezeitende: enrichedWorker.probezeitende ?? "undefined",

                end_date: enrichedWorker.end_date ?? "null",
              });

              console.groupEnd();
            }
          } else {
            console.log(
              `⚠ No matching workerHoursOverview data found for ${worker.name}`,
            );
          }
        } else {
          console.log(
            `⚠ workerHoursOverview not available, using query43 data only`,
          );
        }

        // Debug worker liveshow data (same as single export)

        debugWorkerLiveshowData(enrichedWorker);

        const documentData = KRAUSSPDFGenerator.transformAPIData(
          enrichedWorker,

          query41Data,

          query45Data,

          query47Data,

          query50Data,

          workerData,

          getGetDurchGefuehrteLSData(),

          query53Data, // Pass absence code mapping
        );

        const filename = `${documentData.employee.name.replace(
          /\s+/g,

          "_",
        )}_Zielvereinbarung_${getSafeDate("YYYY-MM")}.pdf`;

        // Generate PDF as blob

        const pdfBlob = await generator.generateDocument(documentData, {
          getBlob: true,
        });

        successCount++;

        results.successful.push({
          name: documentData.employee.name,

          filename: filename,
        });

        console.log(`✓ Generated PDF for ${documentData.employee.name}`);

        return {
          filename: filename,

          blob: pdfBlob,
        };
      } catch (workerError) {
        errorCount++;

        const errorInfo = {
          name: worker.name || "Unknown",

          error: workerError.message,
        };

        results.failed.push(errorInfo);

        console.error(
          `✗ Error processing ${errorInfo.name}:`,

          workerError.message,
        );

        return null;
      }
    });

    // Wait for all PDFs to be generated

    await showNotification(
      "Generiere alle PDFs... ⚙️",

      `${workerData.length} Zielvereinbarungen werden parallel erstellt`,

      "info",

      3,

      true,
    );

    console.log("Waiting for all PDFs to be generated...");

    const pdfResults = await Promise.all(pdfPromises);

    // Add successful PDFs to ZIP

    const validPdfs = pdfResults.filter((result) => result !== null);

    if (validPdfs.length === 0) {
      showNotification(
        "Keine gültigen PDFs ❌",

        "Es konnten keine Zielvereinbarungen erfolgreich generiert werden",

        "error",

        6,
      );

      throw new Error("No valid PDFs were generated");
    }

    // Show ZIP creation progress

    await showNotification(
      "ZIP wird erstellt... 📦",

      `${validPdfs.length} PDFs werden gepackt`,

      "info",

      3,

      true,
    );

    console.log(`Adding ${validPdfs.length} PDFs to ZIP...`);

    for (const pdfResult of validPdfs) {
      zip.file(pdfResult.filename, pdfResult.blob);
    }

    // Generate ZIP file with progress notification

    await showNotification(
      "ZIP wird komprimiert... 🗜️",

      "Optimiere Dateigröße für Download",

      "info",

      2,

      true,
    );

    console.log("Generating ZIP file...");

    const zipBlob = await zip.generateAsync({
      type: "blob",

      compression: "DEFLATE",

      compressionOptions: {
        level: 6,
      },
    });

    // Download ZIP file

    const zipFilename = `Zielvereinbarungen_${getSafeDate("YYYY-MM")}_${
      validPdfs.length
    }_Mitarbeiter.zip`;

    console.log("Attempting to download ZIP file:", zipFilename);

    try {
      // Try Retool-specific download method first

      if (typeof utils !== "undefined" && utils.downloadFile) {
        console.log("Using Retool utils.downloadFile");

        // Don't pass mime type as third parameter - it causes filename issues

        await utils.downloadFile(zipBlob, zipFilename);
      } else {
        // Fallback to standard downloadBlob

        console.log("Using standard downloadBlob method");

        downloadBlob(zipBlob, zipFilename);
      }
    } catch (downloadError) {
      console.error("Error downloading ZIP:", downloadError);

      // Last resort: Convert to base64 and offer as data URL

      try {
        console.log("Attempting base64 conversion as last resort");

        const base64 = await zip.generateAsync({ type: "base64" });

        const dataUrl = `data:application/zip;base64,${base64}`;

        // Try to trigger download via data URL

        const a = document.createElement("a");

        a.href = dataUrl;

        a.download = zipFilename;

        document.body.appendChild(a);

        a.click();

        document.body.removeChild(a);
      } catch (base64Error) {
        console.error("Base64 conversion also failed:", base64Error);

        throw new Error(`Download failed: ${downloadError.message}`);
      }
    }

    console.timeEnd("⏱️ Batch ZIP Processing");

    // Show completion notification with detailed info

    console.group("📦 Batch Results");

    console.table([
      {
        total: workerData.length,

        successful: successCount,

        failed: errorCount,

        successRate: `${Math.round((successCount / workerData.length) * 100)}%`,
      },
    ]);

    console.groupEnd();

    if (errorCount === 0) {
      showNotification(
        "ZIP-Download erfolgreich erstellt! 📦",

        `${successCount} Zielvereinbarungen wurden in ${zipFilename} gepackt`,

        "success",

        6,
      );
    } else if (successCount > 0) {
      showNotification(
        "ZIP-Download mit Warnungen erstellt ⚠️",

        `${successCount} erfolgreich, ${errorCount} fehlgeschlagen. ZIP: ${zipFilename}`,

        "warning",

        8,
      );
    } else {
      showNotification(
        "ZIP-Download fehlgeschlagen ❌",

        `Alle ${errorCount} Versuche sind fehlgeschlagen`,

        "error",

        8,
      );
    }

    return {
      success: successCount,

      errors: errorCount,

      total: workerData.length,

      zipFilename: zipFilename,

      results: results,
    };
  } catch (error) {
    console.error("Batch ZIP Processing Error:", error);

    showNotification(
      "ZIP-Erstellung fehlgeschlagen ❌",

      `Batch-Verarbeitung konnte nicht abgeschlossen werden: ${error.message}`,

      "error",

      8,
    );

    return { success: false, error: error.message };
  }
}

/**
 * ALTERNATIVE BATCH PROCESSING - Generate individual PDF downloads
 * Use this as fallback if ZIP generation fails
 * Requires: query43 with worker data array
 */

async function generateBatchWorkerAgreementsIndividual() {
  try {
    const generator = new KRAUSSPDFGenerator();

    // Get worker data from query

    const workerData = query43?.data;

    if (!workerData || !Array.isArray(workerData) || workerData.length === 0) {
      showNotification(
        "Keine Daten verfügbar ⚠️",

        "Es wurden keine Mitarbeiterdaten für die Batch-Verarbeitung gefunden",

        "warning",

        5,
      );

      throw new Error("No worker data available for batch processing");
    }

    // Show start notification

    showNotification(
      "Download-Serie gestartet... 📄",

      `${workerData.length} Zielvereinbarungen werden einzeln heruntergeladen`,

      "info",

      3,
    );

    console.time("⏱️ Individual Batch Processing");

    console.info(
      `🚀 Starting individual batch processing for ${workerData.length} workers`,
    );

    // Debug: Check what fields are available in query43 data

    if (workerData.length > 0) {
      console.groupCollapsed("📊 Query43 Data Structure");

      const firstWorker = workerData[0];

      console.log("Available fields:", Object.keys(firstWorker).length);

      console.table([
        {
          probezeitende: firstWorker.probezeitende ?? "undefined",

          end_date: firstWorker.end_date ?? "null",

          start_date: firstWorker.start_date,
        },
      ]);

      console.assert(
        firstWorker.probezeitende ||
          firstWorker.end_date ||
          firstWorker.start_date,

        "⚠️ WARNING: No date fields available! Probation period will be calculated from start_date",
      );

      console.groupEnd();
    }

    // Get query41 premium data once for all workers

    const query41Data = getQuery41Data();

    const query45Data = getQuery45Data();

    const query47Data = getQuery47Data();

    const query50Data = getQuery50Data();

    const query53Data = getQuery53Data();

    console.log(
      "Using query53 absence code data for batch processing:",

      query53Data,
    );

    let successCount = 0;

    let errorCount = 0;

    const results = {
      successful: [],

      failed: [],
    };

    // Process each worker with progress tracking

    for (let i = 0; i < workerData.length; i++) {
      const worker = workerData[i];

      const progress = Math.round(((i + 1) / workerData.length) * 100);

      // Show progress notifications every 25% or for small batches every 3 items

      const showProgress =
        (i + 1) % Math.max(1, Math.floor(workerData.length / 4)) === 0 ||
        (workerData.length <= 12 && (i + 1) % 3 === 0);

      if (showProgress && i < workerData.length - 1) {
        showNotification(
          `Fortschritt: ${progress}% ⏳`,

          `${i + 1} von ${workerData.length} Zielvereinbarungen verarbeitet`,

          "info",

          2,
        );
      }

      try {
        console.log(
          `Processing ${i + 1}/${workerData.length}: ${
            worker.name || "Unknown"
          } (${progress}%)`,
        );

        // Ensure worker data is complete - merge with workerHoursOverview if needed

        // This ensures batch has same data structure as single export

        let enrichedWorker = worker;

        // Check if we have workerHoursOverview data and merge if available

        if (
          typeof workerHoursOverview !== "undefined" &&
          workerHoursOverview?.data
        ) {
          const matchingOverviewWorker = workerHoursOverview.data.find(
            (w) =>
              w._id === worker._id ||
              w.id === worker.id ||
              w.name === worker.name,
          );

          if (matchingOverviewWorker) {
            if (i === 0) {
              console.groupCollapsed(`🔄 Data Merge: ${worker.name}`);

              console.table([
                {
                  source: "query43",

                  probezeitende: worker.probezeitende ?? "undefined",

                  end_date: worker.end_date ?? "null",

                  start_date: worker.start_date,
                },

                {
                  source: "overview",

                  probezeitende:
                    matchingOverviewWorker.probezeitende ?? "undefined",

                  end_date: matchingOverviewWorker.end_date ?? "null",

                  start_date: matchingOverviewWorker.start_date,
                },
              ]);
            }

            // Smart merge: start with query43, then override with non-null values from overview

            // This preserves probezeitende and other overview-specific fields

            enrichedWorker = { ...worker };

            Object.keys(matchingOverviewWorker).forEach((key) => {
              // Only overwrite if overview value is not null/undefined OR if worker doesn't have it

              if (matchingOverviewWorker[key] != null || worker[key] == null) {
                enrichedWorker[key] = matchingOverviewWorker[key];
              }
            });

            if (i === 0) {
              console.log("✅ Merged:", {
                probezeitende: enrichedWorker.probezeitende ?? "undefined",

                end_date: enrichedWorker.end_date ?? "null",
              });

              console.groupEnd();
            }
          } else {
            console.log(
              `⚠ No matching workerHoursOverview data found for ${worker.name}`,
            );
          }
        } else {
          console.log(
            `⚠ workerHoursOverview not available, using query43 data only`,
          );
        }

        // Debug worker liveshow data (same as single export)

        debugWorkerLiveshowData(enrichedWorker);

        const documentData = KRAUSSPDFGenerator.transformAPIData(
          enrichedWorker,

          query41Data,

          query45Data,

          query47Data,

          query50Data,

          workerData,

          getGetDurchGefuehrteLSData(),

          query53Data, // Pass absence code mapping
        );

        const filename = `${documentData.employee.name.replace(
          /\s+/g,

          "_",
        )}_Zielvereinbarung_${getSafeDate("YYYY-MM")}.pdf`;

        await generator.generateDocument(documentData, {
          download: true,

          filename: filename,
        });

        successCount++;

        results.successful.push({
          name: documentData.employee.name,

          filename: filename,
        });

        console.log(`✓ Generated PDF for ${documentData.employee.name}`);

        // Small delay between downloads to avoid browser blocking

        await new Promise((resolve) => setTimeout(resolve, 800));
      } catch (workerError) {
        errorCount++;

        const errorInfo = {
          name: worker.name || "Unknown",

          error: workerError.message,
        };

        results.failed.push(errorInfo);

        console.error(
          `✗ Error processing ${errorInfo.name}:`,

          workerError.message,
        );
      }
    }

    // Show completion notification

    if (errorCount === 0) {
      showNotification(
        "Batch-Download abgeschlossen! 📄",

        `${successCount} Zielvereinbarungen wurden einzeln heruntergeladen`,

        "success",

        5,
      );
    } else if (successCount > 0) {
      showNotification(
        "Batch-Download mit Warnungen ⚠️",

        `${successCount} erfolgreich, ${errorCount} fehlgeschlagen`,

        "warning",

        7,
      );
    } else {
      showNotification(
        "Batch-Download fehlgeschlagen ❌",

        `Alle ${errorCount} Versuche sind fehlgeschlagen`,

        "error",

        7,
      );
    }

    return {
      success: successCount,

      errors: errorCount,

      total: workerData.length,

      results: results,
    };
  } catch (error) {
    console.error("Individual Batch Processing Error:", error);

    showNotification(
      "Batch-Verarbeitung fehlgeschlagen ❌",

      `Einzelner Download konnte nicht abgeschlossen werden: ${error.message}`,

      "error",

      7,
    );

    return { success: false, error: error.message };
  }
}

// ===== USAGE GUIDE =====

/**
 * SETUP INSTRUCTIONS:
 *
 * 1. Include this script in your Retool app
 * 2. Add these CDN links to your app header:
 *    - https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/pdfmake.min.js
 *    - https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/vfs_fonts.js
 *    - https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js (for ZIP downloads)
 *
 * 3. Create buttons with onClick handlers:
 *    - generateWorkerAgreementPDF() - Single worker from selected row
 *    - generateBatchWorkerAgreements() - Batch process all workers as ZIP download
 *    - generateBatchWorkerAgreementsIndividual() - Batch process as individual downloads
 *    - previewWorkerAgreementPDF() - Preview PDF in browser
 *    - validateWorkerData() - Validate worker data
 *    - testAPITransformation() - Test with sample data
 *    - testQuery41PremiumData() - Test premium data integration
 *
 * 4. Required Retool components:
 *    - workerHoursOverview (table) - For single worker selection
 *    - query43 (query) - Array of all worker data for batch processing
 *    - query41 (query) - Premium per project data (optional)
 *    - query45 (query) - Premium per activity type data (optional)
 *    - query47 (query) - Premium per project by hours data (optional)
 *
 * 5. ENHANCED USER EXPERIENCE:
 *    - Smart notification system using utils.showNotification()
 *    - Progress tracking for batch operations with real-time updates
 *    - Detailed error messages with actionable information
 *    - Automatic fallback from ZIP to individual downloads when needed
 *    - Color-coded notifications (success=green, warning=yellow, error=red, info=blue)
 *
 * 6. NEW ZIP DOWNLOAD FEATURES:
 *    - generateBatchWorkerAgreements() now creates a single ZIP file
 *    - Contains all PDFs in one convenient download
 *    - Uses Promise.all() for efficient parallel processing
 *    - Automatically loads JSZip library if not available
 *    - Fallback to individual downloads if ZIP fails
 *
 * 7. Premium Data Integration:
 *    - The script includes hardcoded query41 data as fallback
 *    - If query41 exists in Retool, it will be used automatically
 *    - Premium data is matched by project name (case-insensitive)
 *    - Falls back to activity-type-based premiums if no match found
 *
 * 8. Optional functions for UI integration:
 *    - getWorkerStatistics() - Get statistics for display
 *    - getFormattedProjectData() - Get project data for tables
 *    - getQuery41Data() - Get current premium data
 *    - parseQuery41Data() - Parse raw query41 data
 *    - testWorkerCalculations() - Debug calculations for selected worker
 *
 * 9. Premium Data Structure (query41.data should contain):
 *    {
 *      "project_name": ["Project1", "Project2", ...],
 *      "premium": [10, 0, 5, ...],
 *      // ... other fields
 *    }
 *
 * 10. Error Handling & Notifications:
 *    - Comprehensive error handling for both single and batch operations
 *    - Progress tracking for batch operations with toast notifications
 *    - Detailed logging for debugging
 *    - Graceful fallbacks when workers have no project data
 *    - Smart user feedback with utils.showNotification()
 *    - Different notification types: success, warning, error, info
 *    - Automatic duration based on message importance
 */

/**
 * COMBINED PDF PROCESSING - Generate all workers in one PDF file
 * All worker documents are combined into a single PDF with page breaks between workers
 */

async function generateBatchWorkerAgreementsCombined() {
  try {
    console.log("Starting combined PDF generation...");

    const generator = new KRAUSSPDFGenerator();

    // Get worker data from query

    const workerData = query43?.data;

    if (!workerData || !Array.isArray(workerData) || workerData.length === 0) {
      await showNotification(
        "Keine Daten verfügbar ⚠️",

        "Es wurden keine Mitarbeiterdaten für die Verarbeitung gefunden",

        "warning",

        5,

        false,
      );

      throw new Error("No worker data available for combined PDF processing");
    }

    // Show start notification

    await showNotification(
      "Kombinierte PDF-Erstellung gestartet... ⏳",

      `${workerData.length} Zielvereinbarungen werden in eine Datei kombiniert`,

      "info",

      3,
    );

    console.time("⏱️ Combined PDF Processing");

    console.info(
      `🚀 Starting combined PDF processing for ${workerData.length} workers`,
    );

    // Get premium data once for all workers

    const query41Data = getQuery41Data();

    const query45Data = getQuery45Data();

    const query47Data = getQuery47Data();

    const query50Data = getQuery50Data();

    const query53Data = getQuery53Data();

    console.log("Using query data for combined PDF processing:", {
      query41: !!query41Data,

      query45: !!query45Data,

      query47: !!query47Data,

      query50: !!query50Data,

      query53: !!query53Data,
    });

    let successCount = 0;

    let errorCount = 0;

    const allDocumentDefinitions = [];

    // Process each worker and collect document definitions

    for (let i = 0; i < workerData.length; i++) {
      const worker = workerData[i];

      const progress = Math.round(((i + 1) / workerData.length) * 100);

      // Show progress every 25%

      if (
        (i + 1) % Math.max(1, Math.floor(workerData.length / 4)) === 0 &&
        i < workerData.length - 1
      ) {
        await showNotification(
          `Fortschritt: ${progress}% ⏳`,

          `${i + 1} von ${workerData.length} Zielvereinbarungen verarbeitet`,

          "info",

          2,
        );
      }

      try {
        console.log(
          `Processing ${i + 1}/${workerData.length}: ${
            worker.name || "Unknown"
          } (${progress}%)`,
        );

        // Enrich worker data (same as other batch functions)

        let enrichedWorker = worker;

        if (
          typeof workerHoursOverview !== "undefined" &&
          workerHoursOverview?.data
        ) {
          const matchingOverviewWorker = workerHoursOverview.data.find(
            (w) =>
              w._id === worker._id ||
              w.id === worker.id ||
              w.name === worker.name,
          );

          if (matchingOverviewWorker) {
            enrichedWorker = { ...worker };

            Object.keys(matchingOverviewWorker).forEach((key) => {
              if (
                matchingOverviewWorker[key] != null ||
                enrichedWorker[key] == null
              ) {
                enrichedWorker[key] = matchingOverviewWorker[key];
              }
            });
          }
        }

        debugWorkerLiveshowData(enrichedWorker);

        const documentData = KRAUSSPDFGenerator.transformAPIData(
          enrichedWorker,

          query41Data,

          query45Data,

          query47Data,

          query50Data,

          workerData,

          getGetDurchGefuehrteLSData(),

          query53Data,
        );

        // Generate document definition (not the PDF blob)

        const docDefinition = generator.createDocumentDefinition(documentData);

        // Add page break after each worker except the last one

        if (i < workerData.length - 1) {
          docDefinition.content.push({ text: "", pageBreak: "after" });
        }

        allDocumentDefinitions.push(docDefinition);

        successCount++;

        console.log(`✓ Processed document for ${documentData.employee.name}`);
      } catch (workerError) {
        errorCount++;

        console.error(
          `✗ Error processing ${worker.name || "Unknown"}:`,

          workerError.message,
        );
      }
    }

    if (allDocumentDefinitions.length === 0) {
      throw new Error("No valid documents were generated");
    }

    // Combine all document definitions into one

    await showNotification(
      "PDF wird kombiniert... 📄",

      `${allDocumentDefinitions.length} Dokumente werden zusammengeführt`,

      "info",

      3,

      true,
    );

    console.log(
      `Combining ${allDocumentDefinitions.length} documents into one PDF...`,
    );

    // Merge all content, styles, and definitions

    const combinedDefinition = {
      pageSize: "A4",

      pageMargins: [40, 60, 40, 60],

      content: [],

      styles: allDocumentDefinitions[0].styles || {},

      defaultStyle: allDocumentDefinitions[0].defaultStyle || {
        font: "Roboto",

        fontSize: 10,
      },
    };

    // Combine all content from all documents

    allDocumentDefinitions.forEach((docDef) => {
      combinedDefinition.content.push(...docDef.content);
    });

    // Generate the combined PDF

    const filename = `Zielvereinbarungen_Kombiniert_${getSafeDate(
      "YYYY-MM",
    )}_${successCount}_Mitarbeiter.pdf`;

    await showNotification(
      "PDF wird erstellt... 🔨",

      "Kombinierte Datei wird generiert",

      "info",

      2,

      true,
    );

    // Create and download the combined PDF

    const pdfDocGenerator = pdfMake.createPdf(combinedDefinition);

    pdfDocGenerator.download(filename);

    console.timeEnd("⏱️ Combined PDF Processing");

    // Show completion notification

    console.group("📄 Combined PDF Results");

    console.table([
      {
        total: workerData.length,

        successful: successCount,

        failed: errorCount,

        successRate: `${Math.round((successCount / workerData.length) * 100)}%`,
      },
    ]);

    console.groupEnd();

    if (errorCount === 0) {
      await showNotification(
        "Kombinierte PDF erfolgreich erstellt! 📄",

        `${successCount} Zielvereinbarungen wurden in ${filename} kombiniert`,

        "success",

        6,

        false,
      );
    } else if (successCount > 0) {
      await showNotification(
        "Kombinierte PDF mit Warnungen erstellt ⚠️",

        `${successCount} erfolgreich, ${errorCount} fehlgeschlagen. Datei: ${filename}`,

        "warning",

        8,

        false,
      );
    }

    return {
      success: successCount,

      errors: errorCount,

      total: workerData.length,

      filename: filename,
    };
  } catch (error) {
    console.error("Combined PDF Processing Error:", error);

    await showNotification(
      "Kombinierte PDF-Erstellung fehlgeschlagen ❌",

      `Verarbeitung konnte nicht abgeschlossen werden: ${error.message}`,

      "error",

      8,

      false,
    );

    return { success: false, error: error.message };
  }
}

/**
 * SMART BATCH PROCESSING - Automatically chooses best download method
 * Use this as the main batch processing function
 * @param {boolean} forceIndividual - Force individual downloads instead of ZIP
 */

async function generateBatchWorkerAgreementsSmart(forceIndividual = false) {
  try {
    // For large batches (>3 workers) or if forced, use ZIP

    const workerData = query43?.data;

    const workerCount = workerData ? workerData.length : 0;

    if (!workerCount) {
      showNotification(
        "Keine Mitarbeiterdaten ⚠️",

        "Es wurden keine Daten für die Verarbeitung gefunden",

        "warning",

        5,
      );

      throw new Error("No worker data available");
    }

    if (!forceIndividual && workerCount > 3) {
      console.log(`Using ZIP download for ${workerCount} workers`);

      showNotification(
        "ZIP-Modus aktiviert 📦",

        `${workerCount} Mitarbeiter werden als ZIP verarbeitet`,

        "info",

        3,
      );

      try {
        return await generateBatchWorkerAgreements();
      } catch (zipError) {
        console.warn(
          "ZIP generation failed, falling back to individual downloads:",

          zipError,
        );

        showNotification(
          "ZIP fehlgeschlagen - Wechsel zu Einzeldownloads ⚠️",

          "Einzelne PDFs werden stattdessen heruntergeladen",

          "warning",

          4,
        );

        return await generateBatchWorkerAgreementsIndividual();
      }
    } else {
      console.log(`Using individual downloads for ${workerCount} workers`);

      showNotification(
        "Einzeldownload-Modus aktiviert 📄",

        `${workerCount} Mitarbeiter werden einzeln verarbeitet`,

        "info",

        3,
      );

      return await generateBatchWorkerAgreementsIndividual();
    }
  } catch (error) {
    console.error("Smart batch processing error:", error);

    showNotification(
      "Batch-Verarbeitung fehlgeschlagen ❌",

      `Unerwarteter Fehler: ${error.message}`,

      "error",

      6,
    );

    throw error;
  }
}

/**
 * TEST FUNCTION - Debug worker data calculations
 * Use this to test and debug calculations for a single worker
 */

function testWorkerCalculations() {
  try {
    // Test with selected worker if available

    const testWorker =
      workerHoursOverview?.selectedRow || (query43?.data && query43.data[0]); // Fallback to first worker from batch

    if (!testWorker) {
      showNotification(
        "Test fehlgeschlagen ⚠️",

        "Keine Mitarbeiterdaten zum Testen verfügbar",

        "warning",

        4,
      );

      console.error("No worker data available for testing");

      return;
    }

    showNotification(
      "Test gestartet 🧪",

      `Berechne Daten für ${testWorker.name || "Unbekannten Mitarbeiter"}`,

      "info",

      3,
    );

    console.log("=== TESTING WORKER CALCULATIONS ===");

    console.log("Raw worker data:", testWorker);

    // Get premium data

    const query41Data = getQuery41Data();

    const query45Data = getQuery45Data();

    const query47Data = getQuery47Data();

    const query50Data = getQuery50Data();

    // Transform the data

    const transformedData = KRAUSSPDFGenerator.transformAPIData(
      testWorker,

      query41Data,

      query45Data,

      query47Data,

      query50Data,

      null, // No global data for test function

      getGetDurchGefuehrteLSData(),
    );

    console.log("Transformed data:", transformedData);

    console.log("Agreement data:", transformedData.agreement);

    console.log("Statistics:", transformedData.statistics);

    showNotification(
      "Test abgeschlossen ✅",

      `Berechnungen für ${transformedData.employee.name} erfolgreich. Details in der Konsole.`,

      "success",

      5,
    );

    return transformedData;
  } catch (error) {
    showNotification(
      "Test fehlgeschlagen ❌",

      `Fehler bei Berechnungen: ${error.message}`,

      "error",

      6,
    );

    console.error("Test failed:", error);

    return null;
  }
}

// Main execution logic

if (sendAll === "single" || sendAll === false || !sendAll) {
  // Single PDF for selected worker

  await generateWorkerAgreementPDF();
} else if (sendAll === "zip" || sendAll === true) {
  // ZIP file with all PDFs (or smart batch for backwards compatibility)

  await generateBatchWorkerAgreementsSmart();
} else if (sendAll === "file") {
  // Combined PDF with all workers in one file

  await generateBatchWorkerAgreementsCombined();
} else {
  console.error(
    `Invalid sendAll value: ${sendAll}. Expected "single", "zip", or "file".`,
  );

  await showNotification(
    "Ungültiger Modus ❌",

    `Unbekannter sendAll-Wert: "${sendAll}". Verwenden Sie "single", "zip" oder "file".`,

    "error",

    5,

    false,
  );

  throw new Error(`Invalid sendAll value: ${sendAll}`);
}

return "Perfect";
